{"ast":null,"code":"'use strict';\n\nvar compact = require('../functions/compact');\nvar defaultsPure = require('../functions/defaultsPure');\nvar fv = require('../functions/escapeFacetValue');\nvar find = require('../functions/find');\nvar findIndex = require('../functions/findIndex');\nvar formatSort = require('../functions/formatSort');\nvar merge = require('../functions/merge');\nvar orderBy = require('../functions/orderBy');\nvar escapeFacetValue = fv.escapeFacetValue;\nvar unescapeFacetValue = fv.unescapeFacetValue;\nvar generateHierarchicalTree = require('./generate-hierarchical-tree');\n\n/**\r\n * @typedef SearchResults.Facet\r\n * @type {object}\r\n * @property {string} name name of the attribute in the record\r\n * @property {object} data the faceting data: value, number of entries\r\n * @property {object} stats undefined unless facet_stats is retrieved from algolia\r\n */\n\n/**\r\n * @typedef SearchResults.HierarchicalFacet\r\n * @type {object}\r\n * @property {string} name name of the current value given the hierarchical level, trimmed.\r\n * If root node, you get the facet name\r\n * @property {number} count number of objects matching this hierarchical value\r\n * @property {string} path the current hierarchical value full path\r\n * @property {boolean} isRefined `true` if the current value was refined, `false` otherwise\r\n * @property {HierarchicalFacet[]} data sub values for the current level\r\n */\n\n/**\r\n * @typedef SearchResults.FacetValue\r\n * @type {object}\r\n * @property {string} name the facet value itself\r\n * @property {number} count times this facet appears in the results\r\n * @property {boolean} isRefined is the facet currently selected\r\n * @property {boolean} isExcluded is the facet currently excluded (only for conjunctive facets)\r\n */\n\n/**\r\n * @typedef Refinement\r\n * @type {object}\r\n * @property {string} type the type of filter used:\r\n * `numeric`, `facet`, `exclude`, `disjunctive`, `hierarchical`\r\n * @property {string} attributeName name of the attribute used for filtering\r\n * @property {string} name the value of the filter\r\n * @property {number} numericValue the value as a number. Only for numeric filters.\r\n * @property {string} operator the operator used. Only for numeric filters.\r\n * @property {number} count the number of computed hits for this filter. Only on facets.\r\n * @property {boolean} exhaustive if the count is exhaustive\r\n */\n\n/**\r\n * Turn an array of attributes in an object of attributes with their position in the array as value\r\n * @param {string[]} attributes the list of attributes in the record\r\n * @return {object} the list of attributes indexed by attribute name\r\n */\nfunction getIndices(attributes) {\n  var indices = {};\n  attributes.forEach(function (val, idx) {\n    indices[val] = idx;\n  });\n  return indices;\n}\nfunction assignFacetStats(dest, facetStats, key) {\n  if (facetStats && facetStats[key]) {\n    dest.stats = facetStats[key];\n  }\n}\n\n/**\r\n * @typedef {Object} HierarchicalFacet\r\n * @property {string} name\r\n * @property {string[]} attributes\r\n */\n\n/**\r\n * @param {HierarchicalFacet[]} hierarchicalFacets All hierarchical facets\r\n * @param {string} hierarchicalAttributeName The name of the hierarchical attribute\r\n * @return {HierarchicalFacet} The hierarchical facet matching the attribute name\r\n */\nfunction findMatchingHierarchicalFacetFromAttributeName(hierarchicalFacets, hierarchicalAttributeName) {\n  return find(hierarchicalFacets, function facetKeyMatchesAttribute(hierarchicalFacet) {\n    var facetNames = hierarchicalFacet.attributes || [];\n    return facetNames.indexOf(hierarchicalAttributeName) > -1;\n  });\n}\n\n// eslint-disable-next-line valid-jsdoc\n/**\r\n * Constructor for SearchResults\r\n * @class\r\n * @classdesc SearchResults contains the results of a query to Algolia using the\r\n * {@link AlgoliaSearchHelper}.\r\n * @param {SearchParameters} state state that led to the response\r\n * @param {array.<object>} results the results from algolia client\r\n * @example <caption>SearchResults of the first query in\r\n * <a href=\"http://demos.algolia.com/instant-search-demo\">the instant search demo</a></caption>\r\n{\r\n   \"hitsPerPage\": 10,\r\n   \"processingTimeMS\": 2,\r\n   \"facets\": [\r\n      {\r\n         \"name\": \"type\",\r\n         \"data\": {\r\n            \"HardGood\": 6627,\r\n            \"BlackTie\": 550,\r\n            \"Music\": 665,\r\n            \"Software\": 131,\r\n            \"Game\": 456,\r\n            \"Movie\": 1571\r\n         },\r\n         \"exhaustive\": false\r\n      },\r\n      {\r\n         \"exhaustive\": false,\r\n         \"data\": {\r\n            \"Free shipping\": 5507\r\n         },\r\n         \"name\": \"shipping\"\r\n      }\r\n  ],\r\n   \"hits\": [\r\n      {\r\n         \"thumbnailImage\": \"http://img.bbystatic.com/BestBuy_US/images/products/1688/1688832_54x108_s.gif\",\r\n         \"_highlightResult\": {\r\n            \"shortDescription\": {\r\n               \"matchLevel\": \"none\",\r\n               \"value\": \"Safeguard your PC, Mac, Android and iOS devices with comprehensive Internet protection\",\r\n               \"matchedWords\": []\r\n            },\r\n            \"category\": {\r\n               \"matchLevel\": \"none\",\r\n               \"value\": \"Computer Security Software\",\r\n               \"matchedWords\": []\r\n            },\r\n            \"manufacturer\": {\r\n               \"matchedWords\": [],\r\n               \"value\": \"Webroot\",\r\n               \"matchLevel\": \"none\"\r\n            },\r\n            \"name\": {\r\n               \"value\": \"Webroot SecureAnywhere Internet Security (3-Device) (1-Year Subscription) - Mac/Windows\",\r\n               \"matchedWords\": [],\r\n               \"matchLevel\": \"none\"\r\n            }\r\n         },\r\n         \"image\": \"http://img.bbystatic.com/BestBuy_US/images/products/1688/1688832_105x210_sc.jpg\",\r\n         \"shipping\": \"Free shipping\",\r\n         \"bestSellingRank\": 4,\r\n         \"shortDescription\": \"Safeguard your PC, Mac, Android and iOS devices with comprehensive Internet protection\",\r\n         \"url\": \"http://www.bestbuy.com/site/webroot-secureanywhere-internet-security-3-devi…d=1219060687969&skuId=1688832&cmp=RMX&ky=2d3GfEmNIzjA0vkzveHdZEBgpPCyMnLTJ\",\r\n         \"name\": \"Webroot SecureAnywhere Internet Security (3-Device) (1-Year Subscription) - Mac/Windows\",\r\n         \"category\": \"Computer Security Software\",\r\n         \"salePrice_range\": \"1 - 50\",\r\n         \"objectID\": \"1688832\",\r\n         \"type\": \"Software\",\r\n         \"customerReviewCount\": 5980,\r\n         \"salePrice\": 49.99,\r\n         \"manufacturer\": \"Webroot\"\r\n      },\r\n      ....\r\n  ],\r\n   \"nbHits\": 10000,\r\n   \"disjunctiveFacets\": [\r\n      {\r\n         \"exhaustive\": false,\r\n         \"data\": {\r\n            \"5\": 183,\r\n            \"12\": 112,\r\n            \"7\": 149,\r\n            ...\r\n         },\r\n         \"name\": \"customerReviewCount\",\r\n         \"stats\": {\r\n            \"max\": 7461,\r\n            \"avg\": 157.939,\r\n            \"min\": 1\r\n         }\r\n      },\r\n      {\r\n         \"data\": {\r\n            \"Printer Ink\": 142,\r\n            \"Wireless Speakers\": 60,\r\n            \"Point & Shoot Cameras\": 48,\r\n            ...\r\n         },\r\n         \"name\": \"category\",\r\n         \"exhaustive\": false\r\n      },\r\n      {\r\n         \"exhaustive\": false,\r\n         \"data\": {\r\n            \"> 5000\": 2,\r\n            \"1 - 50\": 6524,\r\n            \"501 - 2000\": 566,\r\n            \"201 - 500\": 1501,\r\n            \"101 - 200\": 1360,\r\n            \"2001 - 5000\": 47\r\n         },\r\n         \"name\": \"salePrice_range\"\r\n      },\r\n      {\r\n         \"data\": {\r\n            \"Dynex™\": 202,\r\n            \"Insignia™\": 230,\r\n            \"PNY\": 72,\r\n            ...\r\n         },\r\n         \"name\": \"manufacturer\",\r\n         \"exhaustive\": false\r\n      }\r\n  ],\r\n   \"query\": \"\",\r\n   \"nbPages\": 100,\r\n   \"page\": 0,\r\n   \"index\": \"bestbuy\"\r\n}\r\n **/\nfunction SearchResults(state, results, options) {\n  var mainSubResponse = results[0];\n  this._rawResults = results;\n\n  // eslint-disable-next-line consistent-this\n  var self = this;\n\n  // https://www.algolia.com/doc/api-reference/api-methods/search/#response\n  Object.keys(mainSubResponse).forEach(function (key) {\n    self[key] = mainSubResponse[key];\n  });\n\n  // Make every key of the result options reachable from the instance\n  Object.keys(options || {}).forEach(function (key) {\n    self[key] = options[key];\n  });\n\n  /**\r\n   * query used to generate the results\r\n   * @name query\r\n   * @member {string}\r\n   * @memberof SearchResults\r\n   * @instance\r\n   */\n  /**\r\n   * The query as parsed by the engine given all the rules.\r\n   * @name parsedQuery\r\n   * @member {string}\r\n   * @memberof SearchResults\r\n   * @instance\r\n   */\n  /**\r\n   * all the records that match the search parameters. Each record is\r\n   * augmented with a new attribute `_highlightResult`\r\n   * which is an object keyed by attribute and with the following properties:\r\n   * - `value` : the value of the facet highlighted (html)\r\n   * - `matchLevel`: `full`, `partial` or `none`, depending on how the query terms match\r\n   * @name hits\r\n   * @member {object[]}\r\n   * @memberof SearchResults\r\n   * @instance\r\n   */\n  /**\r\n   * index where the results come from\r\n   * @name index\r\n   * @member {string}\r\n   * @memberof SearchResults\r\n   * @instance\r\n   */\n  /**\r\n   * number of hits per page requested\r\n   * @name hitsPerPage\r\n   * @member {number}\r\n   * @memberof SearchResults\r\n   * @instance\r\n   */\n  /**\r\n   * total number of hits of this query on the index\r\n   * @name nbHits\r\n   * @member {number}\r\n   * @memberof SearchResults\r\n   * @instance\r\n   */\n  /**\r\n   * total number of pages with respect to the number of hits per page and the total number of hits\r\n   * @name nbPages\r\n   * @member {number}\r\n   * @memberof SearchResults\r\n   * @instance\r\n   */\n  /**\r\n   * current page\r\n   * @name page\r\n   * @member {number}\r\n   * @memberof SearchResults\r\n   * @instance\r\n   */\n  /**\r\n   * The position if the position was guessed by IP.\r\n   * @name aroundLatLng\r\n   * @member {string}\r\n   * @memberof SearchResults\r\n   * @instance\r\n   * @example \"48.8637,2.3615\",\r\n   */\n  /**\r\n   * The radius computed by Algolia.\r\n   * @name automaticRadius\r\n   * @member {string}\r\n   * @memberof SearchResults\r\n   * @instance\r\n   * @example \"126792922\",\r\n   */\n  /**\r\n   * String identifying the server used to serve this request.\r\n   *\r\n   * getRankingInfo needs to be set to `true` for this to be returned\r\n   *\r\n   * @name serverUsed\r\n   * @member {string}\r\n   * @memberof SearchResults\r\n   * @instance\r\n   * @example \"c7-use-2.algolia.net\",\r\n   */\n  /**\r\n   * Boolean that indicates if the computation of the counts did time out.\r\n   * @deprecated\r\n   * @name timeoutCounts\r\n   * @member {boolean}\r\n   * @memberof SearchResults\r\n   * @instance\r\n   */\n  /**\r\n   * Boolean that indicates if the computation of the hits did time out.\r\n   * @deprecated\r\n   * @name timeoutHits\r\n   * @member {boolean}\r\n   * @memberof SearchResults\r\n   * @instance\r\n   */\n  /**\r\n   * True if the counts of the facets is exhaustive\r\n   * @name exhaustiveFacetsCount\r\n   * @member {boolean}\r\n   * @memberof SearchResults\r\n   * @instance\r\n   */\n  /**\r\n   * True if the number of hits is exhaustive\r\n   * @name exhaustiveNbHits\r\n   * @member {boolean}\r\n   * @memberof SearchResults\r\n   * @instance\r\n   */\n  /**\r\n   * Contains the userData if they are set by a [query rule](https://www.algolia.com/doc/guides/query-rules/query-rules-overview/).\r\n   * @name userData\r\n   * @member {object[]}\r\n   * @memberof SearchResults\r\n   * @instance\r\n   */\n  /**\r\n   * queryID is the unique identifier of the query used to generate the current search results.\r\n   * This value is only available if the `clickAnalytics` search parameter is set to `true`.\r\n   * @name queryID\r\n   * @member {string}\r\n   * @memberof SearchResults\r\n   * @instance\r\n   */\n\n  /**\r\n   * sum of the processing time of all the queries\r\n   * @name processingTimeMS\r\n   * @member {number}\r\n   * @memberof SearchResults\r\n   * @instance\r\n   */\n  this.processingTimeMS = results.reduce(function (sum, result) {\n    return result.processingTimeMS === undefined ? sum : sum + result.processingTimeMS;\n  }, 0);\n\n  /**\r\n   * disjunctive facets results\r\n   * @member {SearchResults.Facet[]}\r\n   */\n  this.disjunctiveFacets = [];\n  /**\r\n   * disjunctive facets results\r\n   * @member {SearchResults.HierarchicalFacet[]}\r\n   */\n  this.hierarchicalFacets = state.hierarchicalFacets.map(function initFutureTree() {\n    return [];\n  });\n  /**\r\n   * other facets results\r\n   * @member {SearchResults.Facet[]}\r\n   */\n  this.facets = [];\n  var disjunctiveFacets = state.getRefinedDisjunctiveFacets();\n  var facetsIndices = getIndices(state.facets);\n  var disjunctiveFacetsIndices = getIndices(state.disjunctiveFacets);\n  var nextDisjunctiveResult = 1;\n\n  // Since we send request only for disjunctive facets that have been refined,\n  // we get the facets information from the first, general, response.\n\n  var mainFacets = mainSubResponse.facets || {};\n  Object.keys(mainFacets).forEach(function (facetKey) {\n    var facetValueObject = mainFacets[facetKey];\n    var hierarchicalFacet = findMatchingHierarchicalFacetFromAttributeName(state.hierarchicalFacets, facetKey);\n    if (hierarchicalFacet) {\n      // Place the hierarchicalFacet data at the correct index depending on\n      // the attributes order that was defined at the helper initialization\n      var facetIndex = hierarchicalFacet.attributes.indexOf(facetKey);\n      var idxAttributeName = findIndex(state.hierarchicalFacets, function (f) {\n        return f.name === hierarchicalFacet.name;\n      });\n      self.hierarchicalFacets[idxAttributeName][facetIndex] = {\n        attribute: facetKey,\n        data: facetValueObject,\n        exhaustive: mainSubResponse.exhaustiveFacetsCount\n      };\n    } else {\n      var isFacetDisjunctive = state.disjunctiveFacets.indexOf(facetKey) !== -1;\n      var isFacetConjunctive = state.facets.indexOf(facetKey) !== -1;\n      var position;\n      if (isFacetDisjunctive) {\n        position = disjunctiveFacetsIndices[facetKey];\n        self.disjunctiveFacets[position] = {\n          name: facetKey,\n          data: facetValueObject,\n          exhaustive: mainSubResponse.exhaustiveFacetsCount\n        };\n        assignFacetStats(self.disjunctiveFacets[position], mainSubResponse.facets_stats, facetKey);\n      }\n      if (isFacetConjunctive) {\n        position = facetsIndices[facetKey];\n        self.facets[position] = {\n          name: facetKey,\n          data: facetValueObject,\n          exhaustive: mainSubResponse.exhaustiveFacetsCount\n        };\n        assignFacetStats(self.facets[position], mainSubResponse.facets_stats, facetKey);\n      }\n    }\n  });\n\n  // Make sure we do not keep holes within the hierarchical facets\n  this.hierarchicalFacets = compact(this.hierarchicalFacets);\n\n  // aggregate the refined disjunctive facets\n  disjunctiveFacets.forEach(function (disjunctiveFacet) {\n    var result = results[nextDisjunctiveResult];\n    var facets = result && result.facets ? result.facets : {};\n    var hierarchicalFacet = state.getHierarchicalFacetByName(disjunctiveFacet);\n\n    // There should be only item in facets.\n    Object.keys(facets).forEach(function (dfacet) {\n      var facetResults = facets[dfacet];\n      var position;\n      if (hierarchicalFacet) {\n        position = findIndex(state.hierarchicalFacets, function (f) {\n          return f.name === hierarchicalFacet.name;\n        });\n        var attributeIndex = findIndex(self.hierarchicalFacets[position], function (f) {\n          return f.attribute === dfacet;\n        });\n\n        // previous refinements and no results so not able to find it\n        if (attributeIndex === -1) {\n          return;\n        }\n        self.hierarchicalFacets[position][attributeIndex].data = merge({}, self.hierarchicalFacets[position][attributeIndex].data, facetResults);\n      } else {\n        position = disjunctiveFacetsIndices[dfacet];\n        var dataFromMainRequest = mainSubResponse.facets && mainSubResponse.facets[dfacet] || {};\n        self.disjunctiveFacets[position] = {\n          name: dfacet,\n          data: defaultsPure({}, facetResults, dataFromMainRequest),\n          exhaustive: result.exhaustiveFacetsCount\n        };\n        assignFacetStats(self.disjunctiveFacets[position], result.facets_stats, dfacet);\n        if (state.disjunctiveFacetsRefinements[dfacet]) {\n          state.disjunctiveFacetsRefinements[dfacet].forEach(function (refinementValue) {\n            // add the disjunctive refinements if it is no more retrieved\n            if (!self.disjunctiveFacets[position].data[refinementValue] && state.disjunctiveFacetsRefinements[dfacet].indexOf(unescapeFacetValue(refinementValue)) > -1) {\n              self.disjunctiveFacets[position].data[refinementValue] = 0;\n            }\n          });\n        }\n      }\n    });\n    nextDisjunctiveResult++;\n  });\n\n  // if we have some parent level values for hierarchical facets, merge them\n  state.getRefinedHierarchicalFacets().forEach(function (refinedFacet) {\n    var hierarchicalFacet = state.getHierarchicalFacetByName(refinedFacet);\n    var separator = state._getHierarchicalFacetSeparator(hierarchicalFacet);\n    var currentRefinement = state.getHierarchicalRefinement(refinedFacet);\n    // if we are already at a root refinement (or no refinement at all), there is no\n    // root level values request\n    if (currentRefinement.length === 0 || currentRefinement[0].split(separator).length < 2) {\n      return;\n    }\n    results.slice(nextDisjunctiveResult).forEach(function (result) {\n      var facets = result && result.facets ? result.facets : {};\n      Object.keys(facets).forEach(function (dfacet) {\n        var facetResults = facets[dfacet];\n        var position = findIndex(state.hierarchicalFacets, function (f) {\n          return f.name === hierarchicalFacet.name;\n        });\n        var attributeIndex = findIndex(self.hierarchicalFacets[position], function (f) {\n          return f.attribute === dfacet;\n        });\n\n        // previous refinements and no results so not able to find it\n        if (attributeIndex === -1) {\n          return;\n        }\n\n        // when we always get root levels, if the hits refinement is `beers > IPA` (count: 5),\n        // then the disjunctive values will be `beers` (count: 100),\n        // but we do not want to display\n        //   | beers (100)\n        //     > IPA (5)\n        // We want\n        //   | beers (5)\n        //     > IPA (5)\n        var defaultData = {};\n        if (currentRefinement.length > 0) {\n          var root = currentRefinement[0].split(separator)[0];\n          defaultData[root] = self.hierarchicalFacets[position][attributeIndex].data[root];\n        }\n        self.hierarchicalFacets[position][attributeIndex].data = defaultsPure(defaultData, facetResults, self.hierarchicalFacets[position][attributeIndex].data);\n      });\n      nextDisjunctiveResult++;\n    });\n  });\n\n  // add the excludes\n  Object.keys(state.facetsExcludes).forEach(function (facetName) {\n    var excludes = state.facetsExcludes[facetName];\n    var position = facetsIndices[facetName];\n    self.facets[position] = {\n      name: facetName,\n      data: mainFacets[facetName],\n      exhaustive: mainSubResponse.exhaustiveFacetsCount\n    };\n    excludes.forEach(function (facetValue) {\n      self.facets[position] = self.facets[position] || {\n        name: facetName\n      };\n      self.facets[position].data = self.facets[position].data || {};\n      self.facets[position].data[facetValue] = 0;\n    });\n  });\n\n  /**\r\n   * @type {Array}\r\n   */\n  this.hierarchicalFacets = this.hierarchicalFacets.map(generateHierarchicalTree(state));\n\n  /**\r\n   * @type {Array}\r\n   */\n  this.facets = compact(this.facets);\n  /**\r\n   * @type {Array}\r\n   */\n  this.disjunctiveFacets = compact(this.disjunctiveFacets);\n  this._state = state;\n}\n\n/**\r\n * Get a facet object with its name\r\n * @deprecated\r\n * @param {string} name name of the faceted attribute\r\n * @return {SearchResults.Facet} the facet object\r\n */\nSearchResults.prototype.getFacetByName = function (name) {\n  function predicate(facet) {\n    return facet.name === name;\n  }\n  return find(this.facets, predicate) || find(this.disjunctiveFacets, predicate) || find(this.hierarchicalFacets, predicate);\n};\n\n/**\r\n * Get the facet values of a specified attribute from a SearchResults object.\r\n * @private\r\n * @param {SearchResults} results the search results to search in\r\n * @param {string} attribute name of the faceted attribute to search for\r\n * @return {array|object} facet values. For the hierarchical facets it is an object.\r\n */\nfunction extractNormalizedFacetValues(results, attribute) {\n  function predicate(facet) {\n    return facet.name === attribute;\n  }\n  if (results._state.isConjunctiveFacet(attribute)) {\n    var facet = find(results.facets, predicate);\n    if (!facet) return [];\n    return Object.keys(facet.data).map(function (name) {\n      var value = escapeFacetValue(name);\n      return {\n        name: name,\n        escapedValue: value,\n        count: facet.data[name],\n        isRefined: results._state.isFacetRefined(attribute, value),\n        isExcluded: results._state.isExcludeRefined(attribute, name)\n      };\n    });\n  } else if (results._state.isDisjunctiveFacet(attribute)) {\n    var disjunctiveFacet = find(results.disjunctiveFacets, predicate);\n    if (!disjunctiveFacet) return [];\n    return Object.keys(disjunctiveFacet.data).map(function (name) {\n      var value = escapeFacetValue(name);\n      return {\n        name: name,\n        escapedValue: value,\n        count: disjunctiveFacet.data[name],\n        isRefined: results._state.isDisjunctiveFacetRefined(attribute, value)\n      };\n    });\n  } else if (results._state.isHierarchicalFacet(attribute)) {\n    var hierarchicalFacetValues = find(results.hierarchicalFacets, predicate);\n    if (!hierarchicalFacetValues) return hierarchicalFacetValues;\n    var hierarchicalFacet = results._state.getHierarchicalFacetByName(attribute);\n    var separator = results._state._getHierarchicalFacetSeparator(hierarchicalFacet);\n    var currentRefinement = unescapeFacetValue(results._state.getHierarchicalRefinement(attribute)[0] || '');\n    if (currentRefinement.indexOf(hierarchicalFacet.rootPath) === 0) {\n      currentRefinement = currentRefinement.replace(hierarchicalFacet.rootPath + separator, '');\n    }\n    var currentRefinementSplit = currentRefinement.split(separator);\n    currentRefinementSplit.unshift(attribute);\n    setIsRefined(hierarchicalFacetValues, currentRefinementSplit, 0);\n    return hierarchicalFacetValues;\n  }\n  return undefined;\n}\n\n/**\r\n * Set the isRefined of a hierarchical facet result based on the current state.\r\n * @param {SearchResults.HierarchicalFacet} item Hierarchical facet to fix\r\n * @param {string[]} currentRefinement array of parts of the current hierarchical refinement\r\n * @param {number} depth recursion depth in the currentRefinement\r\n * @return {undefined} function mutates the item\r\n */\nfunction setIsRefined(item, currentRefinement, depth) {\n  item.isRefined = item.name === currentRefinement[depth];\n  if (item.data) {\n    item.data.forEach(function (child) {\n      setIsRefined(child, currentRefinement, depth + 1);\n    });\n  }\n}\n\n/**\r\n * Sort nodes of a hierarchical or disjunctive facet results\r\n * @private\r\n * @param {function} sortFn sort function to apply\r\n * @param {HierarchicalFacet|Array} node node upon which we want to apply the sort\r\n * @param {string[]} names attribute names\r\n * @param {number} [level=0] current index in the names array\r\n * @return {HierarchicalFacet|Array} sorted node\r\n */\nfunction recSort(sortFn, node, names, level) {\n  level = level || 0;\n  if (Array.isArray(node)) {\n    return sortFn(node, names[level]);\n  }\n  if (!node.data || node.data.length === 0) {\n    return node;\n  }\n  var children = node.data.map(function (childNode) {\n    return recSort(sortFn, childNode, names, level + 1);\n  });\n  var sortedChildren = sortFn(children, names[level]);\n  var newNode = defaultsPure({\n    data: sortedChildren\n  }, node);\n  return newNode;\n}\nSearchResults.DEFAULT_SORT = ['isRefined:desc', 'count:desc', 'name:asc'];\nfunction vanillaSortFn(order, data) {\n  return data.sort(order);\n}\n\n/**\r\n * @typedef FacetOrdering\r\n * @type {Object}\r\n * @property {string[]} [order]\r\n * @property {'count' | 'alpha' | 'hidden'} [sortRemainingBy]\r\n */\n\n/**\r\n * Sorts facet arrays via their facet ordering\r\n * @param {Array} facetValues the values\r\n * @param {FacetOrdering} facetOrdering the ordering\r\n * @returns {Array} the sorted facet values\r\n */\nfunction sortViaFacetOrdering(facetValues, facetOrdering) {\n  var orderedFacets = [];\n  var remainingFacets = [];\n  var order = facetOrdering.order || [];\n  /**\r\n   * an object with the keys being the values in order, the values their index:\r\n   * ['one', 'two'] -> { one: 0, two: 1 }\r\n   */\n  var reverseOrder = order.reduce(function (acc, name, i) {\n    acc[name] = i;\n    return acc;\n  }, {});\n  facetValues.forEach(function (item) {\n    // hierarchical facets get sorted using their raw name\n    var name = item.path || item.name;\n    if (reverseOrder[name] !== undefined) {\n      orderedFacets[reverseOrder[name]] = item;\n    } else {\n      remainingFacets.push(item);\n    }\n  });\n  orderedFacets = orderedFacets.filter(function (facet) {\n    return facet;\n  });\n  var sortRemainingBy = facetOrdering.sortRemainingBy;\n  var ordering;\n  if (sortRemainingBy === 'hidden') {\n    return orderedFacets;\n  } else if (sortRemainingBy === 'alpha') {\n    ordering = [['path', 'name'], ['asc', 'asc']];\n  } else {\n    ordering = [['count'], ['desc']];\n  }\n  return orderedFacets.concat(orderBy(remainingFacets, ordering[0], ordering[1]));\n}\n\n/**\r\n * @param {SearchResults} results the search results class\r\n * @param {string} attribute the attribute to retrieve ordering of\r\n * @returns {FacetOrdering | undefined} the facet ordering\r\n */\nfunction getFacetOrdering(results, attribute) {\n  return results.renderingContent && results.renderingContent.facetOrdering && results.renderingContent.facetOrdering.values && results.renderingContent.facetOrdering.values[attribute];\n}\n\n/**\r\n * Get a the list of values for a given facet attribute. Those values are sorted\r\n * refinement first, descending count (bigger value on top), and name ascending\r\n * (alphabetical order). The sort formula can overridden using either string based\r\n * predicates or a function.\r\n *\r\n * This method will return all the values returned by the Algolia engine plus all\r\n * the values already refined. This means that it can happen that the\r\n * `maxValuesPerFacet` [configuration](https://www.algolia.com/doc/rest-api/search#param-maxValuesPerFacet)\r\n * might not be respected if you have facet values that are already refined.\r\n * @param {string} attribute attribute name\r\n * @param {object} opts configuration options.\r\n * @param {boolean} [opts.facetOrdering]\r\n * Force the use of facetOrdering from the result if a sortBy is present. If\r\n * sortBy isn't present, facetOrdering will be used automatically.\r\n * @param {Array.<string> | function} opts.sortBy\r\n * When using strings, it consists of\r\n * the name of the [FacetValue](#SearchResults.FacetValue) or the\r\n * [HierarchicalFacet](#SearchResults.HierarchicalFacet) attributes with the\r\n * order (`asc` or `desc`). For example to order the value by count, the\r\n * argument would be `['count:asc']`.\r\n *\r\n * If only the attribute name is specified, the ordering defaults to the one\r\n * specified in the default value for this attribute.\r\n *\r\n * When not specified, the order is\r\n * ascending.  This parameter can also be a function which takes two facet\r\n * values and should return a number, 0 if equal, 1 if the first argument is\r\n * bigger or -1 otherwise.\r\n *\r\n * The default value for this attribute `['isRefined:desc', 'count:desc', 'name:asc']`\r\n * @return {FacetValue[]|HierarchicalFacet|undefined} depending on the type of facet of\r\n * the attribute requested (hierarchical, disjunctive or conjunctive)\r\n * @example\r\n * helper.on('result', function(event){\r\n *   //get values ordered only by name ascending using the string predicate\r\n *   event.results.getFacetValues('city', {sortBy: ['name:asc']});\r\n *   //get values  ordered only by count ascending using a function\r\n *   event.results.getFacetValues('city', {\r\n *     // this is equivalent to ['count:asc']\r\n *     sortBy: function(a, b) {\r\n *       if (a.count === b.count) return 0;\r\n *       if (a.count > b.count)   return 1;\r\n *       if (b.count > a.count)   return -1;\r\n *     }\r\n *   });\r\n * });\r\n */\nSearchResults.prototype.getFacetValues = function (attribute, opts) {\n  var facetValues = extractNormalizedFacetValues(this, attribute);\n  if (!facetValues) {\n    return undefined;\n  }\n  var options = defaultsPure({}, opts, {\n    sortBy: SearchResults.DEFAULT_SORT,\n    // if no sortBy is given, attempt to sort based on facetOrdering\n    // if it is given, we still allow to sort via facet ordering first\n    facetOrdering: !(opts && opts.sortBy)\n  });\n\n  // eslint-disable-next-line consistent-this\n  var results = this;\n  var attributes;\n  if (Array.isArray(facetValues)) {\n    attributes = [attribute];\n  } else {\n    var config = results._state.getHierarchicalFacetByName(facetValues.name);\n    attributes = config.attributes;\n  }\n  return recSort(function (data, facetName) {\n    if (options.facetOrdering) {\n      var facetOrdering = getFacetOrdering(results, facetName);\n      if (facetOrdering) {\n        return sortViaFacetOrdering(data, facetOrdering);\n      }\n    }\n    if (Array.isArray(options.sortBy)) {\n      var order = formatSort(options.sortBy, SearchResults.DEFAULT_SORT);\n      return orderBy(data, order[0], order[1]);\n    } else if (typeof options.sortBy === 'function') {\n      return vanillaSortFn(options.sortBy, data);\n    }\n    throw new Error('options.sortBy is optional but if defined it must be ' + 'either an array of string (predicates) or a sorting function');\n  }, facetValues, attributes);\n};\n\n/**\r\n * Returns the facet stats if attribute is defined and the facet contains some.\r\n * Otherwise returns undefined.\r\n * @param {string} attribute name of the faceted attribute\r\n * @return {object} The stats of the facet\r\n */\nSearchResults.prototype.getFacetStats = function (attribute) {\n  if (this._state.isConjunctiveFacet(attribute)) {\n    return getFacetStatsIfAvailable(this.facets, attribute);\n  } else if (this._state.isDisjunctiveFacet(attribute)) {\n    return getFacetStatsIfAvailable(this.disjunctiveFacets, attribute);\n  }\n  return undefined;\n};\n\n/**\r\n * @typedef {Object} FacetListItem\r\n * @property {string} name\r\n */\n\n/**\r\n * @param {FacetListItem[]} facetList (has more items, but enough for here)\r\n * @param {string} facetName The attribute to look for\r\n * @return {object|undefined} The stats of the facet\r\n */\nfunction getFacetStatsIfAvailable(facetList, facetName) {\n  var data = find(facetList, function (facet) {\n    return facet.name === facetName;\n  });\n  return data && data.stats;\n}\n\n/**\r\n * Returns all refinements for all filters + tags. It also provides\r\n * additional information: count and exhaustiveness for each filter.\r\n *\r\n * See the [refinement type](#Refinement) for an exhaustive view of the available\r\n * data.\r\n *\r\n * Note that for a numeric refinement, results are grouped per operator, this\r\n * means that it will return responses for operators which are empty.\r\n *\r\n * @return {Array.<Refinement>} all the refinements\r\n */\nSearchResults.prototype.getRefinements = function () {\n  var state = this._state;\n  // eslint-disable-next-line consistent-this\n  var results = this;\n  var res = [];\n  Object.keys(state.facetsRefinements).forEach(function (attributeName) {\n    state.facetsRefinements[attributeName].forEach(function (name) {\n      res.push(getRefinement(state, 'facet', attributeName, name, results.facets));\n    });\n  });\n  Object.keys(state.facetsExcludes).forEach(function (attributeName) {\n    state.facetsExcludes[attributeName].forEach(function (name) {\n      res.push(getRefinement(state, 'exclude', attributeName, name, results.facets));\n    });\n  });\n  Object.keys(state.disjunctiveFacetsRefinements).forEach(function (attributeName) {\n    state.disjunctiveFacetsRefinements[attributeName].forEach(function (name) {\n      res.push(getRefinement(state, 'disjunctive', attributeName, name, results.disjunctiveFacets));\n    });\n  });\n  Object.keys(state.hierarchicalFacetsRefinements).forEach(function (attributeName) {\n    state.hierarchicalFacetsRefinements[attributeName].forEach(function (name) {\n      res.push(getHierarchicalRefinement(state, attributeName, name, results.hierarchicalFacets));\n    });\n  });\n  Object.keys(state.numericRefinements).forEach(function (attributeName) {\n    var operators = state.numericRefinements[attributeName];\n    Object.keys(operators).forEach(function (operator) {\n      operators[operator].forEach(function (value) {\n        res.push({\n          type: 'numeric',\n          attributeName: attributeName,\n          name: value,\n          numericValue: value,\n          operator: operator\n        });\n      });\n    });\n  });\n  state.tagRefinements.forEach(function (name) {\n    res.push({\n      type: 'tag',\n      attributeName: '_tags',\n      name: name\n    });\n  });\n  return res;\n};\n\n/**\r\n * @typedef {Object} Facet\r\n * @property {string} name\r\n * @property {Object} data\r\n * @property {boolean} exhaustive\r\n */\n\n/**\r\n * @param {SearchParameters} state the current state\r\n * @param {string} type the type of the refinement\r\n * @param {string} attributeName The attribute of the facet\r\n * @param {*} name The name of the facet\r\n * @param {Facet[]} resultsFacets facets from the results\r\n * @return {Refinement} the refinement\r\n */\nfunction getRefinement(state, type, attributeName, name, resultsFacets) {\n  var facet = find(resultsFacets, function (f) {\n    return f.name === attributeName;\n  });\n  var count = facet && facet.data && facet.data[name] ? facet.data[name] : 0;\n  var exhaustive = facet && facet.exhaustive || false;\n  return {\n    type: type,\n    attributeName: attributeName,\n    name: name,\n    count: count,\n    exhaustive: exhaustive\n  };\n}\n\n/**\r\n * @param {SearchParameters} state the current state\r\n * @param {string} attributeName the attribute of the hierarchical facet\r\n * @param {string} name the name of the facet\r\n * @param {Facet[]} resultsFacets facets from the results\r\n * @return {HierarchicalFacet} the hierarchical facet\r\n */\nfunction getHierarchicalRefinement(state, attributeName, name, resultsFacets) {\n  var facetDeclaration = state.getHierarchicalFacetByName(attributeName);\n  var separator = state._getHierarchicalFacetSeparator(facetDeclaration);\n  var split = name.split(separator);\n  var rootFacet = find(resultsFacets, function (facet) {\n    return facet.name === attributeName;\n  });\n  var facet = split.reduce(function (intermediateFacet, part) {\n    var newFacet = intermediateFacet && find(intermediateFacet.data, function (f) {\n      return f.name === part;\n    });\n    return newFacet !== undefined ? newFacet : intermediateFacet;\n  }, rootFacet);\n  var count = facet && facet.count || 0;\n  var exhaustive = facet && facet.exhaustive || false;\n  var path = facet && facet.path || '';\n  return {\n    type: 'hierarchical',\n    attributeName: attributeName,\n    name: path,\n    count: count,\n    exhaustive: exhaustive\n  };\n}\nmodule.exports = SearchResults;","map":{"version":3,"names":["compact","require","defaultsPure","fv","find","findIndex","formatSort","merge","orderBy","escapeFacetValue","unescapeFacetValue","generateHierarchicalTree","getIndices","attributes","indices","forEach","val","idx","assignFacetStats","dest","facetStats","key","stats","findMatchingHierarchicalFacetFromAttributeName","hierarchicalFacets","hierarchicalAttributeName","facetKeyMatchesAttribute","hierarchicalFacet","facetNames","indexOf","SearchResults","state","results","options","mainSubResponse","_rawResults","self","Object","keys","processingTimeMS","reduce","sum","result","undefined","disjunctiveFacets","map","initFutureTree","facets","getRefinedDisjunctiveFacets","facetsIndices","disjunctiveFacetsIndices","nextDisjunctiveResult","mainFacets","facetKey","facetValueObject","facetIndex","idxAttributeName","f","name","attribute","data","exhaustive","exhaustiveFacetsCount","isFacetDisjunctive","isFacetConjunctive","position","facets_stats","disjunctiveFacet","getHierarchicalFacetByName","dfacet","facetResults","attributeIndex","dataFromMainRequest","disjunctiveFacetsRefinements","refinementValue","getRefinedHierarchicalFacets","refinedFacet","separator","_getHierarchicalFacetSeparator","currentRefinement","getHierarchicalRefinement","length","split","slice","defaultData","root","facetsExcludes","facetName","excludes","facetValue","_state","prototype","getFacetByName","predicate","facet","extractNormalizedFacetValues","isConjunctiveFacet","value","escapedValue","count","isRefined","isFacetRefined","isExcluded","isExcludeRefined","isDisjunctiveFacet","isDisjunctiveFacetRefined","isHierarchicalFacet","hierarchicalFacetValues","rootPath","replace","currentRefinementSplit","unshift","setIsRefined","item","depth","child","recSort","sortFn","node","names","level","Array","isArray","children","childNode","sortedChildren","newNode","DEFAULT_SORT","vanillaSortFn","order","sort","sortViaFacetOrdering","facetValues","facetOrdering","orderedFacets","remainingFacets","reverseOrder","acc","i","path","push","filter","sortRemainingBy","ordering","concat","getFacetOrdering","renderingContent","values","getFacetValues","opts","sortBy","config","Error","getFacetStats","getFacetStatsIfAvailable","facetList","getRefinements","res","facetsRefinements","attributeName","getRefinement","hierarchicalFacetsRefinements","numericRefinements","operators","operator","type","numericValue","tagRefinements","resultsFacets","facetDeclaration","rootFacet","intermediateFacet","part","newFacet","module","exports"],"sources":["C:/Users/tudor/propr/RepositoryNetlify/node_modules/react-instantsearch-core/node_modules/algoliasearch-helper/src/SearchResults/index.js"],"sourcesContent":["'use strict';\r\n\r\nvar compact = require('../functions/compact');\r\nvar defaultsPure = require('../functions/defaultsPure');\r\nvar fv = require('../functions/escapeFacetValue');\r\nvar find = require('../functions/find');\r\nvar findIndex = require('../functions/findIndex');\r\nvar formatSort = require('../functions/formatSort');\r\nvar merge = require('../functions/merge');\r\nvar orderBy = require('../functions/orderBy');\r\nvar escapeFacetValue = fv.escapeFacetValue;\r\nvar unescapeFacetValue = fv.unescapeFacetValue;\r\n\r\nvar generateHierarchicalTree = require('./generate-hierarchical-tree');\r\n\r\n/**\r\n * @typedef SearchResults.Facet\r\n * @type {object}\r\n * @property {string} name name of the attribute in the record\r\n * @property {object} data the faceting data: value, number of entries\r\n * @property {object} stats undefined unless facet_stats is retrieved from algolia\r\n */\r\n\r\n/**\r\n * @typedef SearchResults.HierarchicalFacet\r\n * @type {object}\r\n * @property {string} name name of the current value given the hierarchical level, trimmed.\r\n * If root node, you get the facet name\r\n * @property {number} count number of objects matching this hierarchical value\r\n * @property {string} path the current hierarchical value full path\r\n * @property {boolean} isRefined `true` if the current value was refined, `false` otherwise\r\n * @property {HierarchicalFacet[]} data sub values for the current level\r\n */\r\n\r\n/**\r\n * @typedef SearchResults.FacetValue\r\n * @type {object}\r\n * @property {string} name the facet value itself\r\n * @property {number} count times this facet appears in the results\r\n * @property {boolean} isRefined is the facet currently selected\r\n * @property {boolean} isExcluded is the facet currently excluded (only for conjunctive facets)\r\n */\r\n\r\n/**\r\n * @typedef Refinement\r\n * @type {object}\r\n * @property {string} type the type of filter used:\r\n * `numeric`, `facet`, `exclude`, `disjunctive`, `hierarchical`\r\n * @property {string} attributeName name of the attribute used for filtering\r\n * @property {string} name the value of the filter\r\n * @property {number} numericValue the value as a number. Only for numeric filters.\r\n * @property {string} operator the operator used. Only for numeric filters.\r\n * @property {number} count the number of computed hits for this filter. Only on facets.\r\n * @property {boolean} exhaustive if the count is exhaustive\r\n */\r\n\r\n/**\r\n * Turn an array of attributes in an object of attributes with their position in the array as value\r\n * @param {string[]} attributes the list of attributes in the record\r\n * @return {object} the list of attributes indexed by attribute name\r\n */\r\nfunction getIndices(attributes) {\r\n  var indices = {};\r\n\r\n  attributes.forEach(function (val, idx) {\r\n    indices[val] = idx;\r\n  });\r\n\r\n  return indices;\r\n}\r\n\r\nfunction assignFacetStats(dest, facetStats, key) {\r\n  if (facetStats && facetStats[key]) {\r\n    dest.stats = facetStats[key];\r\n  }\r\n}\r\n\r\n/**\r\n * @typedef {Object} HierarchicalFacet\r\n * @property {string} name\r\n * @property {string[]} attributes\r\n */\r\n\r\n/**\r\n * @param {HierarchicalFacet[]} hierarchicalFacets All hierarchical facets\r\n * @param {string} hierarchicalAttributeName The name of the hierarchical attribute\r\n * @return {HierarchicalFacet} The hierarchical facet matching the attribute name\r\n */\r\nfunction findMatchingHierarchicalFacetFromAttributeName(\r\n  hierarchicalFacets,\r\n  hierarchicalAttributeName\r\n) {\r\n  return find(\r\n    hierarchicalFacets,\r\n    function facetKeyMatchesAttribute(hierarchicalFacet) {\r\n      var facetNames = hierarchicalFacet.attributes || [];\r\n      return facetNames.indexOf(hierarchicalAttributeName) > -1;\r\n    }\r\n  );\r\n}\r\n\r\n// eslint-disable-next-line valid-jsdoc\r\n/**\r\n * Constructor for SearchResults\r\n * @class\r\n * @classdesc SearchResults contains the results of a query to Algolia using the\r\n * {@link AlgoliaSearchHelper}.\r\n * @param {SearchParameters} state state that led to the response\r\n * @param {array.<object>} results the results from algolia client\r\n * @example <caption>SearchResults of the first query in\r\n * <a href=\"http://demos.algolia.com/instant-search-demo\">the instant search demo</a></caption>\r\n{\r\n   \"hitsPerPage\": 10,\r\n   \"processingTimeMS\": 2,\r\n   \"facets\": [\r\n      {\r\n         \"name\": \"type\",\r\n         \"data\": {\r\n            \"HardGood\": 6627,\r\n            \"BlackTie\": 550,\r\n            \"Music\": 665,\r\n            \"Software\": 131,\r\n            \"Game\": 456,\r\n            \"Movie\": 1571\r\n         },\r\n         \"exhaustive\": false\r\n      },\r\n      {\r\n         \"exhaustive\": false,\r\n         \"data\": {\r\n            \"Free shipping\": 5507\r\n         },\r\n         \"name\": \"shipping\"\r\n      }\r\n  ],\r\n   \"hits\": [\r\n      {\r\n         \"thumbnailImage\": \"http://img.bbystatic.com/BestBuy_US/images/products/1688/1688832_54x108_s.gif\",\r\n         \"_highlightResult\": {\r\n            \"shortDescription\": {\r\n               \"matchLevel\": \"none\",\r\n               \"value\": \"Safeguard your PC, Mac, Android and iOS devices with comprehensive Internet protection\",\r\n               \"matchedWords\": []\r\n            },\r\n            \"category\": {\r\n               \"matchLevel\": \"none\",\r\n               \"value\": \"Computer Security Software\",\r\n               \"matchedWords\": []\r\n            },\r\n            \"manufacturer\": {\r\n               \"matchedWords\": [],\r\n               \"value\": \"Webroot\",\r\n               \"matchLevel\": \"none\"\r\n            },\r\n            \"name\": {\r\n               \"value\": \"Webroot SecureAnywhere Internet Security (3-Device) (1-Year Subscription) - Mac/Windows\",\r\n               \"matchedWords\": [],\r\n               \"matchLevel\": \"none\"\r\n            }\r\n         },\r\n         \"image\": \"http://img.bbystatic.com/BestBuy_US/images/products/1688/1688832_105x210_sc.jpg\",\r\n         \"shipping\": \"Free shipping\",\r\n         \"bestSellingRank\": 4,\r\n         \"shortDescription\": \"Safeguard your PC, Mac, Android and iOS devices with comprehensive Internet protection\",\r\n         \"url\": \"http://www.bestbuy.com/site/webroot-secureanywhere-internet-security-3-devi…d=1219060687969&skuId=1688832&cmp=RMX&ky=2d3GfEmNIzjA0vkzveHdZEBgpPCyMnLTJ\",\r\n         \"name\": \"Webroot SecureAnywhere Internet Security (3-Device) (1-Year Subscription) - Mac/Windows\",\r\n         \"category\": \"Computer Security Software\",\r\n         \"salePrice_range\": \"1 - 50\",\r\n         \"objectID\": \"1688832\",\r\n         \"type\": \"Software\",\r\n         \"customerReviewCount\": 5980,\r\n         \"salePrice\": 49.99,\r\n         \"manufacturer\": \"Webroot\"\r\n      },\r\n      ....\r\n  ],\r\n   \"nbHits\": 10000,\r\n   \"disjunctiveFacets\": [\r\n      {\r\n         \"exhaustive\": false,\r\n         \"data\": {\r\n            \"5\": 183,\r\n            \"12\": 112,\r\n            \"7\": 149,\r\n            ...\r\n         },\r\n         \"name\": \"customerReviewCount\",\r\n         \"stats\": {\r\n            \"max\": 7461,\r\n            \"avg\": 157.939,\r\n            \"min\": 1\r\n         }\r\n      },\r\n      {\r\n         \"data\": {\r\n            \"Printer Ink\": 142,\r\n            \"Wireless Speakers\": 60,\r\n            \"Point & Shoot Cameras\": 48,\r\n            ...\r\n         },\r\n         \"name\": \"category\",\r\n         \"exhaustive\": false\r\n      },\r\n      {\r\n         \"exhaustive\": false,\r\n         \"data\": {\r\n            \"> 5000\": 2,\r\n            \"1 - 50\": 6524,\r\n            \"501 - 2000\": 566,\r\n            \"201 - 500\": 1501,\r\n            \"101 - 200\": 1360,\r\n            \"2001 - 5000\": 47\r\n         },\r\n         \"name\": \"salePrice_range\"\r\n      },\r\n      {\r\n         \"data\": {\r\n            \"Dynex™\": 202,\r\n            \"Insignia™\": 230,\r\n            \"PNY\": 72,\r\n            ...\r\n         },\r\n         \"name\": \"manufacturer\",\r\n         \"exhaustive\": false\r\n      }\r\n  ],\r\n   \"query\": \"\",\r\n   \"nbPages\": 100,\r\n   \"page\": 0,\r\n   \"index\": \"bestbuy\"\r\n}\r\n **/\r\nfunction SearchResults(state, results, options) {\r\n  var mainSubResponse = results[0];\r\n\r\n  this._rawResults = results;\r\n\r\n  // eslint-disable-next-line consistent-this\r\n  var self = this;\r\n\r\n  // https://www.algolia.com/doc/api-reference/api-methods/search/#response\r\n  Object.keys(mainSubResponse).forEach(function (key) {\r\n    self[key] = mainSubResponse[key];\r\n  });\r\n\r\n  // Make every key of the result options reachable from the instance\r\n  Object.keys(options || {}).forEach(function (key) {\r\n    self[key] = options[key];\r\n  });\r\n\r\n  /**\r\n   * query used to generate the results\r\n   * @name query\r\n   * @member {string}\r\n   * @memberof SearchResults\r\n   * @instance\r\n   */\r\n  /**\r\n   * The query as parsed by the engine given all the rules.\r\n   * @name parsedQuery\r\n   * @member {string}\r\n   * @memberof SearchResults\r\n   * @instance\r\n   */\r\n  /**\r\n   * all the records that match the search parameters. Each record is\r\n   * augmented with a new attribute `_highlightResult`\r\n   * which is an object keyed by attribute and with the following properties:\r\n   * - `value` : the value of the facet highlighted (html)\r\n   * - `matchLevel`: `full`, `partial` or `none`, depending on how the query terms match\r\n   * @name hits\r\n   * @member {object[]}\r\n   * @memberof SearchResults\r\n   * @instance\r\n   */\r\n  /**\r\n   * index where the results come from\r\n   * @name index\r\n   * @member {string}\r\n   * @memberof SearchResults\r\n   * @instance\r\n   */\r\n  /**\r\n   * number of hits per page requested\r\n   * @name hitsPerPage\r\n   * @member {number}\r\n   * @memberof SearchResults\r\n   * @instance\r\n   */\r\n  /**\r\n   * total number of hits of this query on the index\r\n   * @name nbHits\r\n   * @member {number}\r\n   * @memberof SearchResults\r\n   * @instance\r\n   */\r\n  /**\r\n   * total number of pages with respect to the number of hits per page and the total number of hits\r\n   * @name nbPages\r\n   * @member {number}\r\n   * @memberof SearchResults\r\n   * @instance\r\n   */\r\n  /**\r\n   * current page\r\n   * @name page\r\n   * @member {number}\r\n   * @memberof SearchResults\r\n   * @instance\r\n   */\r\n  /**\r\n   * The position if the position was guessed by IP.\r\n   * @name aroundLatLng\r\n   * @member {string}\r\n   * @memberof SearchResults\r\n   * @instance\r\n   * @example \"48.8637,2.3615\",\r\n   */\r\n  /**\r\n   * The radius computed by Algolia.\r\n   * @name automaticRadius\r\n   * @member {string}\r\n   * @memberof SearchResults\r\n   * @instance\r\n   * @example \"126792922\",\r\n   */\r\n  /**\r\n   * String identifying the server used to serve this request.\r\n   *\r\n   * getRankingInfo needs to be set to `true` for this to be returned\r\n   *\r\n   * @name serverUsed\r\n   * @member {string}\r\n   * @memberof SearchResults\r\n   * @instance\r\n   * @example \"c7-use-2.algolia.net\",\r\n   */\r\n  /**\r\n   * Boolean that indicates if the computation of the counts did time out.\r\n   * @deprecated\r\n   * @name timeoutCounts\r\n   * @member {boolean}\r\n   * @memberof SearchResults\r\n   * @instance\r\n   */\r\n  /**\r\n   * Boolean that indicates if the computation of the hits did time out.\r\n   * @deprecated\r\n   * @name timeoutHits\r\n   * @member {boolean}\r\n   * @memberof SearchResults\r\n   * @instance\r\n   */\r\n  /**\r\n   * True if the counts of the facets is exhaustive\r\n   * @name exhaustiveFacetsCount\r\n   * @member {boolean}\r\n   * @memberof SearchResults\r\n   * @instance\r\n   */\r\n  /**\r\n   * True if the number of hits is exhaustive\r\n   * @name exhaustiveNbHits\r\n   * @member {boolean}\r\n   * @memberof SearchResults\r\n   * @instance\r\n   */\r\n  /**\r\n   * Contains the userData if they are set by a [query rule](https://www.algolia.com/doc/guides/query-rules/query-rules-overview/).\r\n   * @name userData\r\n   * @member {object[]}\r\n   * @memberof SearchResults\r\n   * @instance\r\n   */\r\n  /**\r\n   * queryID is the unique identifier of the query used to generate the current search results.\r\n   * This value is only available if the `clickAnalytics` search parameter is set to `true`.\r\n   * @name queryID\r\n   * @member {string}\r\n   * @memberof SearchResults\r\n   * @instance\r\n   */\r\n\r\n  /**\r\n   * sum of the processing time of all the queries\r\n   * @name processingTimeMS\r\n   * @member {number}\r\n   * @memberof SearchResults\r\n   * @instance\r\n   */\r\n  this.processingTimeMS = results.reduce(function (sum, result) {\r\n    return result.processingTimeMS === undefined\r\n      ? sum\r\n      : sum + result.processingTimeMS;\r\n  }, 0);\r\n\r\n  /**\r\n   * disjunctive facets results\r\n   * @member {SearchResults.Facet[]}\r\n   */\r\n  this.disjunctiveFacets = [];\r\n  /**\r\n   * disjunctive facets results\r\n   * @member {SearchResults.HierarchicalFacet[]}\r\n   */\r\n  this.hierarchicalFacets = state.hierarchicalFacets.map(\r\n    function initFutureTree() {\r\n      return [];\r\n    }\r\n  );\r\n  /**\r\n   * other facets results\r\n   * @member {SearchResults.Facet[]}\r\n   */\r\n  this.facets = [];\r\n\r\n  var disjunctiveFacets = state.getRefinedDisjunctiveFacets();\r\n\r\n  var facetsIndices = getIndices(state.facets);\r\n  var disjunctiveFacetsIndices = getIndices(state.disjunctiveFacets);\r\n  var nextDisjunctiveResult = 1;\r\n\r\n  // Since we send request only for disjunctive facets that have been refined,\r\n  // we get the facets information from the first, general, response.\r\n\r\n  var mainFacets = mainSubResponse.facets || {};\r\n\r\n  Object.keys(mainFacets).forEach(function (facetKey) {\r\n    var facetValueObject = mainFacets[facetKey];\r\n\r\n    var hierarchicalFacet = findMatchingHierarchicalFacetFromAttributeName(\r\n      state.hierarchicalFacets,\r\n      facetKey\r\n    );\r\n\r\n    if (hierarchicalFacet) {\r\n      // Place the hierarchicalFacet data at the correct index depending on\r\n      // the attributes order that was defined at the helper initialization\r\n      var facetIndex = hierarchicalFacet.attributes.indexOf(facetKey);\r\n      var idxAttributeName = findIndex(state.hierarchicalFacets, function (f) {\r\n        return f.name === hierarchicalFacet.name;\r\n      });\r\n      self.hierarchicalFacets[idxAttributeName][facetIndex] = {\r\n        attribute: facetKey,\r\n        data: facetValueObject,\r\n        exhaustive: mainSubResponse.exhaustiveFacetsCount,\r\n      };\r\n    } else {\r\n      var isFacetDisjunctive = state.disjunctiveFacets.indexOf(facetKey) !== -1;\r\n      var isFacetConjunctive = state.facets.indexOf(facetKey) !== -1;\r\n      var position;\r\n\r\n      if (isFacetDisjunctive) {\r\n        position = disjunctiveFacetsIndices[facetKey];\r\n        self.disjunctiveFacets[position] = {\r\n          name: facetKey,\r\n          data: facetValueObject,\r\n          exhaustive: mainSubResponse.exhaustiveFacetsCount,\r\n        };\r\n        assignFacetStats(\r\n          self.disjunctiveFacets[position],\r\n          mainSubResponse.facets_stats,\r\n          facetKey\r\n        );\r\n      }\r\n      if (isFacetConjunctive) {\r\n        position = facetsIndices[facetKey];\r\n        self.facets[position] = {\r\n          name: facetKey,\r\n          data: facetValueObject,\r\n          exhaustive: mainSubResponse.exhaustiveFacetsCount,\r\n        };\r\n        assignFacetStats(\r\n          self.facets[position],\r\n          mainSubResponse.facets_stats,\r\n          facetKey\r\n        );\r\n      }\r\n    }\r\n  });\r\n\r\n  // Make sure we do not keep holes within the hierarchical facets\r\n  this.hierarchicalFacets = compact(this.hierarchicalFacets);\r\n\r\n  // aggregate the refined disjunctive facets\r\n  disjunctiveFacets.forEach(function (disjunctiveFacet) {\r\n    var result = results[nextDisjunctiveResult];\r\n    var facets = result && result.facets ? result.facets : {};\r\n    var hierarchicalFacet = state.getHierarchicalFacetByName(disjunctiveFacet);\r\n\r\n    // There should be only item in facets.\r\n    Object.keys(facets).forEach(function (dfacet) {\r\n      var facetResults = facets[dfacet];\r\n\r\n      var position;\r\n\r\n      if (hierarchicalFacet) {\r\n        position = findIndex(state.hierarchicalFacets, function (f) {\r\n          return f.name === hierarchicalFacet.name;\r\n        });\r\n        var attributeIndex = findIndex(\r\n          self.hierarchicalFacets[position],\r\n          function (f) {\r\n            return f.attribute === dfacet;\r\n          }\r\n        );\r\n\r\n        // previous refinements and no results so not able to find it\r\n        if (attributeIndex === -1) {\r\n          return;\r\n        }\r\n\r\n        self.hierarchicalFacets[position][attributeIndex].data = merge(\r\n          {},\r\n          self.hierarchicalFacets[position][attributeIndex].data,\r\n          facetResults\r\n        );\r\n      } else {\r\n        position = disjunctiveFacetsIndices[dfacet];\r\n\r\n        var dataFromMainRequest =\r\n          (mainSubResponse.facets && mainSubResponse.facets[dfacet]) || {};\r\n\r\n        self.disjunctiveFacets[position] = {\r\n          name: dfacet,\r\n          data: defaultsPure({}, facetResults, dataFromMainRequest),\r\n          exhaustive: result.exhaustiveFacetsCount,\r\n        };\r\n        assignFacetStats(\r\n          self.disjunctiveFacets[position],\r\n          result.facets_stats,\r\n          dfacet\r\n        );\r\n\r\n        if (state.disjunctiveFacetsRefinements[dfacet]) {\r\n          state.disjunctiveFacetsRefinements[dfacet].forEach(function (\r\n            refinementValue\r\n          ) {\r\n            // add the disjunctive refinements if it is no more retrieved\r\n            if (\r\n              !self.disjunctiveFacets[position].data[refinementValue] &&\r\n              state.disjunctiveFacetsRefinements[dfacet].indexOf(\r\n                unescapeFacetValue(refinementValue)\r\n              ) > -1\r\n            ) {\r\n              self.disjunctiveFacets[position].data[refinementValue] = 0;\r\n            }\r\n          });\r\n        }\r\n      }\r\n    });\r\n    nextDisjunctiveResult++;\r\n  });\r\n\r\n  // if we have some parent level values for hierarchical facets, merge them\r\n  state.getRefinedHierarchicalFacets().forEach(function (refinedFacet) {\r\n    var hierarchicalFacet = state.getHierarchicalFacetByName(refinedFacet);\r\n    var separator = state._getHierarchicalFacetSeparator(hierarchicalFacet);\r\n\r\n    var currentRefinement = state.getHierarchicalRefinement(refinedFacet);\r\n    // if we are already at a root refinement (or no refinement at all), there is no\r\n    // root level values request\r\n    if (\r\n      currentRefinement.length === 0 ||\r\n      currentRefinement[0].split(separator).length < 2\r\n    ) {\r\n      return;\r\n    }\r\n\r\n    results.slice(nextDisjunctiveResult).forEach(function (result) {\r\n      var facets = result && result.facets ? result.facets : {};\r\n\r\n      Object.keys(facets).forEach(function (dfacet) {\r\n        var facetResults = facets[dfacet];\r\n        var position = findIndex(state.hierarchicalFacets, function (f) {\r\n          return f.name === hierarchicalFacet.name;\r\n        });\r\n        var attributeIndex = findIndex(\r\n          self.hierarchicalFacets[position],\r\n          function (f) {\r\n            return f.attribute === dfacet;\r\n          }\r\n        );\r\n\r\n        // previous refinements and no results so not able to find it\r\n        if (attributeIndex === -1) {\r\n          return;\r\n        }\r\n\r\n        // when we always get root levels, if the hits refinement is `beers > IPA` (count: 5),\r\n        // then the disjunctive values will be `beers` (count: 100),\r\n        // but we do not want to display\r\n        //   | beers (100)\r\n        //     > IPA (5)\r\n        // We want\r\n        //   | beers (5)\r\n        //     > IPA (5)\r\n        var defaultData = {};\r\n\r\n        if (currentRefinement.length > 0) {\r\n          var root = currentRefinement[0].split(separator)[0];\r\n          defaultData[root] =\r\n            self.hierarchicalFacets[position][attributeIndex].data[root];\r\n        }\r\n\r\n        self.hierarchicalFacets[position][attributeIndex].data = defaultsPure(\r\n          defaultData,\r\n          facetResults,\r\n          self.hierarchicalFacets[position][attributeIndex].data\r\n        );\r\n      });\r\n\r\n      nextDisjunctiveResult++;\r\n    });\r\n  });\r\n\r\n  // add the excludes\r\n  Object.keys(state.facetsExcludes).forEach(function (facetName) {\r\n    var excludes = state.facetsExcludes[facetName];\r\n    var position = facetsIndices[facetName];\r\n\r\n    self.facets[position] = {\r\n      name: facetName,\r\n      data: mainFacets[facetName],\r\n      exhaustive: mainSubResponse.exhaustiveFacetsCount,\r\n    };\r\n    excludes.forEach(function (facetValue) {\r\n      self.facets[position] = self.facets[position] || { name: facetName };\r\n      self.facets[position].data = self.facets[position].data || {};\r\n      self.facets[position].data[facetValue] = 0;\r\n    });\r\n  });\r\n\r\n  /**\r\n   * @type {Array}\r\n   */\r\n  this.hierarchicalFacets = this.hierarchicalFacets.map(\r\n    generateHierarchicalTree(state)\r\n  );\r\n\r\n  /**\r\n   * @type {Array}\r\n   */\r\n  this.facets = compact(this.facets);\r\n  /**\r\n   * @type {Array}\r\n   */\r\n  this.disjunctiveFacets = compact(this.disjunctiveFacets);\r\n\r\n  this._state = state;\r\n}\r\n\r\n/**\r\n * Get a facet object with its name\r\n * @deprecated\r\n * @param {string} name name of the faceted attribute\r\n * @return {SearchResults.Facet} the facet object\r\n */\r\nSearchResults.prototype.getFacetByName = function (name) {\r\n  function predicate(facet) {\r\n    return facet.name === name;\r\n  }\r\n\r\n  return (\r\n    find(this.facets, predicate) ||\r\n    find(this.disjunctiveFacets, predicate) ||\r\n    find(this.hierarchicalFacets, predicate)\r\n  );\r\n};\r\n\r\n/**\r\n * Get the facet values of a specified attribute from a SearchResults object.\r\n * @private\r\n * @param {SearchResults} results the search results to search in\r\n * @param {string} attribute name of the faceted attribute to search for\r\n * @return {array|object} facet values. For the hierarchical facets it is an object.\r\n */\r\nfunction extractNormalizedFacetValues(results, attribute) {\r\n  function predicate(facet) {\r\n    return facet.name === attribute;\r\n  }\r\n\r\n  if (results._state.isConjunctiveFacet(attribute)) {\r\n    var facet = find(results.facets, predicate);\r\n    if (!facet) return [];\r\n\r\n    return Object.keys(facet.data).map(function (name) {\r\n      var value = escapeFacetValue(name);\r\n      return {\r\n        name: name,\r\n        escapedValue: value,\r\n        count: facet.data[name],\r\n        isRefined: results._state.isFacetRefined(attribute, value),\r\n        isExcluded: results._state.isExcludeRefined(attribute, name),\r\n      };\r\n    });\r\n  } else if (results._state.isDisjunctiveFacet(attribute)) {\r\n    var disjunctiveFacet = find(results.disjunctiveFacets, predicate);\r\n    if (!disjunctiveFacet) return [];\r\n\r\n    return Object.keys(disjunctiveFacet.data).map(function (name) {\r\n      var value = escapeFacetValue(name);\r\n      return {\r\n        name: name,\r\n        escapedValue: value,\r\n        count: disjunctiveFacet.data[name],\r\n        isRefined: results._state.isDisjunctiveFacetRefined(attribute, value),\r\n      };\r\n    });\r\n  } else if (results._state.isHierarchicalFacet(attribute)) {\r\n    var hierarchicalFacetValues = find(results.hierarchicalFacets, predicate);\r\n    if (!hierarchicalFacetValues) return hierarchicalFacetValues;\r\n\r\n    var hierarchicalFacet =\r\n      results._state.getHierarchicalFacetByName(attribute);\r\n    var separator =\r\n      results._state._getHierarchicalFacetSeparator(hierarchicalFacet);\r\n    var currentRefinement = unescapeFacetValue(\r\n      results._state.getHierarchicalRefinement(attribute)[0] || ''\r\n    );\r\n\r\n    if (currentRefinement.indexOf(hierarchicalFacet.rootPath) === 0) {\r\n      currentRefinement = currentRefinement.replace(\r\n        hierarchicalFacet.rootPath + separator,\r\n        ''\r\n      );\r\n    }\r\n\r\n    var currentRefinementSplit = currentRefinement.split(separator);\r\n    currentRefinementSplit.unshift(attribute);\r\n\r\n    setIsRefined(hierarchicalFacetValues, currentRefinementSplit, 0);\r\n\r\n    return hierarchicalFacetValues;\r\n  }\r\n\r\n  return undefined;\r\n}\r\n\r\n/**\r\n * Set the isRefined of a hierarchical facet result based on the current state.\r\n * @param {SearchResults.HierarchicalFacet} item Hierarchical facet to fix\r\n * @param {string[]} currentRefinement array of parts of the current hierarchical refinement\r\n * @param {number} depth recursion depth in the currentRefinement\r\n * @return {undefined} function mutates the item\r\n */\r\nfunction setIsRefined(item, currentRefinement, depth) {\r\n  item.isRefined = item.name === currentRefinement[depth];\r\n  if (item.data) {\r\n    item.data.forEach(function (child) {\r\n      setIsRefined(child, currentRefinement, depth + 1);\r\n    });\r\n  }\r\n}\r\n\r\n/**\r\n * Sort nodes of a hierarchical or disjunctive facet results\r\n * @private\r\n * @param {function} sortFn sort function to apply\r\n * @param {HierarchicalFacet|Array} node node upon which we want to apply the sort\r\n * @param {string[]} names attribute names\r\n * @param {number} [level=0] current index in the names array\r\n * @return {HierarchicalFacet|Array} sorted node\r\n */\r\nfunction recSort(sortFn, node, names, level) {\r\n  level = level || 0;\r\n\r\n  if (Array.isArray(node)) {\r\n    return sortFn(node, names[level]);\r\n  }\r\n\r\n  if (!node.data || node.data.length === 0) {\r\n    return node;\r\n  }\r\n\r\n  var children = node.data.map(function (childNode) {\r\n    return recSort(sortFn, childNode, names, level + 1);\r\n  });\r\n  var sortedChildren = sortFn(children, names[level]);\r\n  var newNode = defaultsPure({ data: sortedChildren }, node);\r\n  return newNode;\r\n}\r\n\r\nSearchResults.DEFAULT_SORT = ['isRefined:desc', 'count:desc', 'name:asc'];\r\n\r\nfunction vanillaSortFn(order, data) {\r\n  return data.sort(order);\r\n}\r\n\r\n/**\r\n * @typedef FacetOrdering\r\n * @type {Object}\r\n * @property {string[]} [order]\r\n * @property {'count' | 'alpha' | 'hidden'} [sortRemainingBy]\r\n */\r\n\r\n/**\r\n * Sorts facet arrays via their facet ordering\r\n * @param {Array} facetValues the values\r\n * @param {FacetOrdering} facetOrdering the ordering\r\n * @returns {Array} the sorted facet values\r\n */\r\nfunction sortViaFacetOrdering(facetValues, facetOrdering) {\r\n  var orderedFacets = [];\r\n  var remainingFacets = [];\r\n\r\n  var order = facetOrdering.order || [];\r\n  /**\r\n   * an object with the keys being the values in order, the values their index:\r\n   * ['one', 'two'] -> { one: 0, two: 1 }\r\n   */\r\n  var reverseOrder = order.reduce(function (acc, name, i) {\r\n    acc[name] = i;\r\n    return acc;\r\n  }, {});\r\n\r\n  facetValues.forEach(function (item) {\r\n    // hierarchical facets get sorted using their raw name\r\n    var name = item.path || item.name;\r\n    if (reverseOrder[name] !== undefined) {\r\n      orderedFacets[reverseOrder[name]] = item;\r\n    } else {\r\n      remainingFacets.push(item);\r\n    }\r\n  });\r\n\r\n  orderedFacets = orderedFacets.filter(function (facet) {\r\n    return facet;\r\n  });\r\n\r\n  var sortRemainingBy = facetOrdering.sortRemainingBy;\r\n  var ordering;\r\n  if (sortRemainingBy === 'hidden') {\r\n    return orderedFacets;\r\n  } else if (sortRemainingBy === 'alpha') {\r\n    ordering = [\r\n      ['path', 'name'],\r\n      ['asc', 'asc'],\r\n    ];\r\n  } else {\r\n    ordering = [['count'], ['desc']];\r\n  }\r\n\r\n  return orderedFacets.concat(\r\n    orderBy(remainingFacets, ordering[0], ordering[1])\r\n  );\r\n}\r\n\r\n/**\r\n * @param {SearchResults} results the search results class\r\n * @param {string} attribute the attribute to retrieve ordering of\r\n * @returns {FacetOrdering | undefined} the facet ordering\r\n */\r\nfunction getFacetOrdering(results, attribute) {\r\n  return (\r\n    results.renderingContent &&\r\n    results.renderingContent.facetOrdering &&\r\n    results.renderingContent.facetOrdering.values &&\r\n    results.renderingContent.facetOrdering.values[attribute]\r\n  );\r\n}\r\n\r\n/**\r\n * Get a the list of values for a given facet attribute. Those values are sorted\r\n * refinement first, descending count (bigger value on top), and name ascending\r\n * (alphabetical order). The sort formula can overridden using either string based\r\n * predicates or a function.\r\n *\r\n * This method will return all the values returned by the Algolia engine plus all\r\n * the values already refined. This means that it can happen that the\r\n * `maxValuesPerFacet` [configuration](https://www.algolia.com/doc/rest-api/search#param-maxValuesPerFacet)\r\n * might not be respected if you have facet values that are already refined.\r\n * @param {string} attribute attribute name\r\n * @param {object} opts configuration options.\r\n * @param {boolean} [opts.facetOrdering]\r\n * Force the use of facetOrdering from the result if a sortBy is present. If\r\n * sortBy isn't present, facetOrdering will be used automatically.\r\n * @param {Array.<string> | function} opts.sortBy\r\n * When using strings, it consists of\r\n * the name of the [FacetValue](#SearchResults.FacetValue) or the\r\n * [HierarchicalFacet](#SearchResults.HierarchicalFacet) attributes with the\r\n * order (`asc` or `desc`). For example to order the value by count, the\r\n * argument would be `['count:asc']`.\r\n *\r\n * If only the attribute name is specified, the ordering defaults to the one\r\n * specified in the default value for this attribute.\r\n *\r\n * When not specified, the order is\r\n * ascending.  This parameter can also be a function which takes two facet\r\n * values and should return a number, 0 if equal, 1 if the first argument is\r\n * bigger or -1 otherwise.\r\n *\r\n * The default value for this attribute `['isRefined:desc', 'count:desc', 'name:asc']`\r\n * @return {FacetValue[]|HierarchicalFacet|undefined} depending on the type of facet of\r\n * the attribute requested (hierarchical, disjunctive or conjunctive)\r\n * @example\r\n * helper.on('result', function(event){\r\n *   //get values ordered only by name ascending using the string predicate\r\n *   event.results.getFacetValues('city', {sortBy: ['name:asc']});\r\n *   //get values  ordered only by count ascending using a function\r\n *   event.results.getFacetValues('city', {\r\n *     // this is equivalent to ['count:asc']\r\n *     sortBy: function(a, b) {\r\n *       if (a.count === b.count) return 0;\r\n *       if (a.count > b.count)   return 1;\r\n *       if (b.count > a.count)   return -1;\r\n *     }\r\n *   });\r\n * });\r\n */\r\nSearchResults.prototype.getFacetValues = function (attribute, opts) {\r\n  var facetValues = extractNormalizedFacetValues(this, attribute);\r\n  if (!facetValues) {\r\n    return undefined;\r\n  }\r\n\r\n  var options = defaultsPure({}, opts, {\r\n    sortBy: SearchResults.DEFAULT_SORT,\r\n    // if no sortBy is given, attempt to sort based on facetOrdering\r\n    // if it is given, we still allow to sort via facet ordering first\r\n    facetOrdering: !(opts && opts.sortBy),\r\n  });\r\n\r\n  // eslint-disable-next-line consistent-this\r\n  var results = this;\r\n  var attributes;\r\n  if (Array.isArray(facetValues)) {\r\n    attributes = [attribute];\r\n  } else {\r\n    var config = results._state.getHierarchicalFacetByName(facetValues.name);\r\n    attributes = config.attributes;\r\n  }\r\n\r\n  return recSort(\r\n    function (data, facetName) {\r\n      if (options.facetOrdering) {\r\n        var facetOrdering = getFacetOrdering(results, facetName);\r\n        if (facetOrdering) {\r\n          return sortViaFacetOrdering(data, facetOrdering);\r\n        }\r\n      }\r\n\r\n      if (Array.isArray(options.sortBy)) {\r\n        var order = formatSort(options.sortBy, SearchResults.DEFAULT_SORT);\r\n        return orderBy(data, order[0], order[1]);\r\n      } else if (typeof options.sortBy === 'function') {\r\n        return vanillaSortFn(options.sortBy, data);\r\n      }\r\n      throw new Error(\r\n        'options.sortBy is optional but if defined it must be ' +\r\n          'either an array of string (predicates) or a sorting function'\r\n      );\r\n    },\r\n    facetValues,\r\n    attributes\r\n  );\r\n};\r\n\r\n/**\r\n * Returns the facet stats if attribute is defined and the facet contains some.\r\n * Otherwise returns undefined.\r\n * @param {string} attribute name of the faceted attribute\r\n * @return {object} The stats of the facet\r\n */\r\nSearchResults.prototype.getFacetStats = function (attribute) {\r\n  if (this._state.isConjunctiveFacet(attribute)) {\r\n    return getFacetStatsIfAvailable(this.facets, attribute);\r\n  } else if (this._state.isDisjunctiveFacet(attribute)) {\r\n    return getFacetStatsIfAvailable(this.disjunctiveFacets, attribute);\r\n  }\r\n\r\n  return undefined;\r\n};\r\n\r\n/**\r\n * @typedef {Object} FacetListItem\r\n * @property {string} name\r\n */\r\n\r\n/**\r\n * @param {FacetListItem[]} facetList (has more items, but enough for here)\r\n * @param {string} facetName The attribute to look for\r\n * @return {object|undefined} The stats of the facet\r\n */\r\nfunction getFacetStatsIfAvailable(facetList, facetName) {\r\n  var data = find(facetList, function (facet) {\r\n    return facet.name === facetName;\r\n  });\r\n  return data && data.stats;\r\n}\r\n\r\n/**\r\n * Returns all refinements for all filters + tags. It also provides\r\n * additional information: count and exhaustiveness for each filter.\r\n *\r\n * See the [refinement type](#Refinement) for an exhaustive view of the available\r\n * data.\r\n *\r\n * Note that for a numeric refinement, results are grouped per operator, this\r\n * means that it will return responses for operators which are empty.\r\n *\r\n * @return {Array.<Refinement>} all the refinements\r\n */\r\nSearchResults.prototype.getRefinements = function () {\r\n  var state = this._state;\r\n  // eslint-disable-next-line consistent-this\r\n  var results = this;\r\n  var res = [];\r\n\r\n  Object.keys(state.facetsRefinements).forEach(function (attributeName) {\r\n    state.facetsRefinements[attributeName].forEach(function (name) {\r\n      res.push(\r\n        getRefinement(state, 'facet', attributeName, name, results.facets)\r\n      );\r\n    });\r\n  });\r\n\r\n  Object.keys(state.facetsExcludes).forEach(function (attributeName) {\r\n    state.facetsExcludes[attributeName].forEach(function (name) {\r\n      res.push(\r\n        getRefinement(state, 'exclude', attributeName, name, results.facets)\r\n      );\r\n    });\r\n  });\r\n\r\n  Object.keys(state.disjunctiveFacetsRefinements).forEach(function (\r\n    attributeName\r\n  ) {\r\n    state.disjunctiveFacetsRefinements[attributeName].forEach(function (name) {\r\n      res.push(\r\n        getRefinement(\r\n          state,\r\n          'disjunctive',\r\n          attributeName,\r\n          name,\r\n          results.disjunctiveFacets\r\n        )\r\n      );\r\n    });\r\n  });\r\n\r\n  Object.keys(state.hierarchicalFacetsRefinements).forEach(function (\r\n    attributeName\r\n  ) {\r\n    state.hierarchicalFacetsRefinements[attributeName].forEach(function (name) {\r\n      res.push(\r\n        getHierarchicalRefinement(\r\n          state,\r\n          attributeName,\r\n          name,\r\n          results.hierarchicalFacets\r\n        )\r\n      );\r\n    });\r\n  });\r\n\r\n  Object.keys(state.numericRefinements).forEach(function (attributeName) {\r\n    var operators = state.numericRefinements[attributeName];\r\n    Object.keys(operators).forEach(function (operator) {\r\n      operators[operator].forEach(function (value) {\r\n        res.push({\r\n          type: 'numeric',\r\n          attributeName: attributeName,\r\n          name: value,\r\n          numericValue: value,\r\n          operator: operator,\r\n        });\r\n      });\r\n    });\r\n  });\r\n\r\n  state.tagRefinements.forEach(function (name) {\r\n    res.push({ type: 'tag', attributeName: '_tags', name: name });\r\n  });\r\n\r\n  return res;\r\n};\r\n\r\n/**\r\n * @typedef {Object} Facet\r\n * @property {string} name\r\n * @property {Object} data\r\n * @property {boolean} exhaustive\r\n */\r\n\r\n/**\r\n * @param {SearchParameters} state the current state\r\n * @param {string} type the type of the refinement\r\n * @param {string} attributeName The attribute of the facet\r\n * @param {*} name The name of the facet\r\n * @param {Facet[]} resultsFacets facets from the results\r\n * @return {Refinement} the refinement\r\n */\r\nfunction getRefinement(state, type, attributeName, name, resultsFacets) {\r\n  var facet = find(resultsFacets, function (f) {\r\n    return f.name === attributeName;\r\n  });\r\n  var count = facet && facet.data && facet.data[name] ? facet.data[name] : 0;\r\n  var exhaustive = (facet && facet.exhaustive) || false;\r\n\r\n  return {\r\n    type: type,\r\n    attributeName: attributeName,\r\n    name: name,\r\n    count: count,\r\n    exhaustive: exhaustive,\r\n  };\r\n}\r\n\r\n/**\r\n * @param {SearchParameters} state the current state\r\n * @param {string} attributeName the attribute of the hierarchical facet\r\n * @param {string} name the name of the facet\r\n * @param {Facet[]} resultsFacets facets from the results\r\n * @return {HierarchicalFacet} the hierarchical facet\r\n */\r\nfunction getHierarchicalRefinement(state, attributeName, name, resultsFacets) {\r\n  var facetDeclaration = state.getHierarchicalFacetByName(attributeName);\r\n  var separator = state._getHierarchicalFacetSeparator(facetDeclaration);\r\n  var split = name.split(separator);\r\n  var rootFacet = find(resultsFacets, function (facet) {\r\n    return facet.name === attributeName;\r\n  });\r\n\r\n  var facet = split.reduce(function (intermediateFacet, part) {\r\n    var newFacet =\r\n      intermediateFacet &&\r\n      find(intermediateFacet.data, function (f) {\r\n        return f.name === part;\r\n      });\r\n    return newFacet !== undefined ? newFacet : intermediateFacet;\r\n  }, rootFacet);\r\n\r\n  var count = (facet && facet.count) || 0;\r\n  var exhaustive = (facet && facet.exhaustive) || false;\r\n  var path = (facet && facet.path) || '';\r\n\r\n  return {\r\n    type: 'hierarchical',\r\n    attributeName: attributeName,\r\n    name: path,\r\n    count: count,\r\n    exhaustive: exhaustive,\r\n  };\r\n}\r\n\r\nmodule.exports = SearchResults;\r\n"],"mappings":"AAAA,YAAY;;AAEZ,IAAIA,OAAO,GAAGC,OAAO,CAAC,sBAAsB,CAAC;AAC7C,IAAIC,YAAY,GAAGD,OAAO,CAAC,2BAA2B,CAAC;AACvD,IAAIE,EAAE,GAAGF,OAAO,CAAC,+BAA+B,CAAC;AACjD,IAAIG,IAAI,GAAGH,OAAO,CAAC,mBAAmB,CAAC;AACvC,IAAII,SAAS,GAAGJ,OAAO,CAAC,wBAAwB,CAAC;AACjD,IAAIK,UAAU,GAAGL,OAAO,CAAC,yBAAyB,CAAC;AACnD,IAAIM,KAAK,GAAGN,OAAO,CAAC,oBAAoB,CAAC;AACzC,IAAIO,OAAO,GAAGP,OAAO,CAAC,sBAAsB,CAAC;AAC7C,IAAIQ,gBAAgB,GAAGN,EAAE,CAACM,gBAAgB;AAC1C,IAAIC,kBAAkB,GAAGP,EAAE,CAACO,kBAAkB;AAE9C,IAAIC,wBAAwB,GAAGV,OAAO,CAAC,8BAA8B,CAAC;;AAEtE;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,SAASW,UAAUA,CAACC,UAAU,EAAE;EAC9B,IAAIC,OAAO,GAAG,CAAC,CAAC;EAEhBD,UAAU,CAACE,OAAO,CAAC,UAAUC,GAAG,EAAEC,GAAG,EAAE;IACrCH,OAAO,CAACE,GAAG,CAAC,GAAGC,GAAG;EACpB,CAAC,CAAC;EAEF,OAAOH,OAAO;AAChB;AAEA,SAASI,gBAAgBA,CAACC,IAAI,EAAEC,UAAU,EAAEC,GAAG,EAAE;EAC/C,IAAID,UAAU,IAAIA,UAAU,CAACC,GAAG,CAAC,EAAE;IACjCF,IAAI,CAACG,KAAK,GAAGF,UAAU,CAACC,GAAG,CAAC;EAC9B;AACF;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,SAASE,8CAA8CA,CACrDC,kBAAkB,EAClBC,yBAAyB,EACzB;EACA,OAAOrB,IAAI,CACToB,kBAAkB,EAClB,SAASE,wBAAwBA,CAACC,iBAAiB,EAAE;IACnD,IAAIC,UAAU,GAAGD,iBAAiB,CAACd,UAAU,IAAI,EAAE;IACnD,OAAOe,UAAU,CAACC,OAAO,CAACJ,yBAAyB,CAAC,GAAG,CAAC,CAAC;EAC3D,CACF,CAAC;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAASK,aAAaA,CAACC,KAAK,EAAEC,OAAO,EAAEC,OAAO,EAAE;EAC9C,IAAIC,eAAe,GAAGF,OAAO,CAAC,CAAC,CAAC;EAEhC,IAAI,CAACG,WAAW,GAAGH,OAAO;;EAE1B;EACA,IAAII,IAAI,GAAG,IAAI;;EAEf;EACAC,MAAM,CAACC,IAAI,CAACJ,eAAe,CAAC,CAACnB,OAAO,CAAC,UAAUM,GAAG,EAAE;IAClDe,IAAI,CAACf,GAAG,CAAC,GAAGa,eAAe,CAACb,GAAG,CAAC;EAClC,CAAC,CAAC;;EAEF;EACAgB,MAAM,CAACC,IAAI,CAACL,OAAO,IAAI,CAAC,CAAC,CAAC,CAAClB,OAAO,CAAC,UAAUM,GAAG,EAAE;IAChDe,IAAI,CAACf,GAAG,CAAC,GAAGY,OAAO,CAACZ,GAAG,CAAC;EAC1B,CAAC,CAAC;;EAEF;AACF;AACA;AACA;AACA;AACA;AACA;EACE;AACF;AACA;AACA;AACA;AACA;AACA;EACE;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACE;AACF;AACA;AACA;AACA;AACA;AACA;EACE;AACF;AACA;AACA;AACA;AACA;AACA;EACE;AACF;AACA;AACA;AACA;AACA;AACA;EACE;AACF;AACA;AACA;AACA;AACA;AACA;EACE;AACF;AACA;AACA;AACA;AACA;AACA;EACE;AACF;AACA;AACA;AACA;AACA;AACA;AACA;EACE;AACF;AACA;AACA;AACA;AACA;AACA;AACA;EACE;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACE;AACF;AACA;AACA;AACA;AACA;AACA;AACA;EACE;AACF;AACA;AACA;AACA;AACA;AACA;AACA;EACE;AACF;AACA;AACA;AACA;AACA;AACA;EACE;AACF;AACA;AACA;AACA;AACA;AACA;EACE;AACF;AACA;AACA;AACA;AACA;AACA;EACE;AACF;AACA;AACA;AACA;AACA;AACA;AACA;;EAEE;AACF;AACA;AACA;AACA;AACA;AACA;EACE,IAAI,CAACkB,gBAAgB,GAAGP,OAAO,CAACQ,MAAM,CAAC,UAAUC,GAAG,EAAEC,MAAM,EAAE;IAC5D,OAAOA,MAAM,CAACH,gBAAgB,KAAKI,SAAS,GACxCF,GAAG,GACHA,GAAG,GAAGC,MAAM,CAACH,gBAAgB;EACnC,CAAC,EAAE,CAAC,CAAC;;EAEL;AACF;AACA;AACA;EACE,IAAI,CAACK,iBAAiB,GAAG,EAAE;EAC3B;AACF;AACA;AACA;EACE,IAAI,CAACpB,kBAAkB,GAAGO,KAAK,CAACP,kBAAkB,CAACqB,GAAG,CACpD,SAASC,cAAcA,CAAA,EAAG;IACxB,OAAO,EAAE;EACX,CACF,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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}