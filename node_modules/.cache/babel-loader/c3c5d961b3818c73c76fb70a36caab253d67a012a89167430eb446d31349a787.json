{"ast":null,"code":"'use strict';\n\n/**\r\n * Functions to manipulate refinement lists\r\n *\r\n * The RefinementList is not formally defined through a prototype but is based\r\n * on a specific structure.\r\n *\r\n * @module SearchParameters.refinementList\r\n *\r\n * @typedef {string[]} SearchParameters.refinementList.Refinements\r\n * @typedef {Object.<string, SearchParameters.refinementList.Refinements>} SearchParameters.refinementList.RefinementList\r\n */\nvar defaultsPure = require('../functions/defaultsPure');\nvar objectHasKeys = require('../functions/objectHasKeys');\nvar omit = require('../functions/omit');\nvar lib = {\n  /**\r\n   * Adds a refinement to a RefinementList\r\n   * @param {RefinementList} refinementList the initial list\r\n   * @param {string} attribute the attribute to refine\r\n   * @param {string} value the value of the refinement, if the value is not a string it will be converted\r\n   * @return {RefinementList} a new and updated refinement list\r\n   */\n  addRefinement: function addRefinement(refinementList, attribute, value) {\n    if (lib.isRefined(refinementList, attribute, value)) {\n      return refinementList;\n    }\n    var valueAsString = '' + value;\n    var facetRefinement = !refinementList[attribute] ? [valueAsString] : refinementList[attribute].concat(valueAsString);\n    var mod = {};\n    mod[attribute] = facetRefinement;\n    return defaultsPure({}, mod, refinementList);\n  },\n  /**\r\n   * Removes refinement(s) for an attribute:\r\n   *  - if the value is specified removes the refinement for the value on the attribute\r\n   *  - if no value is specified removes all the refinements for this attribute\r\n   * @param {RefinementList} refinementList the initial list\r\n   * @param {string} attribute the attribute to refine\r\n   * @param {string} [value] the value of the refinement\r\n   * @return {RefinementList} a new and updated refinement lst\r\n   */\n  removeRefinement: function removeRefinement(refinementList, attribute, value) {\n    if (value === undefined) {\n      // we use the \"filter\" form of clearRefinement, since it leaves empty values as-is\n      // the form with a string will remove the attribute completely\n      return lib.clearRefinement(refinementList, function (v, f) {\n        return attribute === f;\n      });\n    }\n    var valueAsString = '' + value;\n    return lib.clearRefinement(refinementList, function (v, f) {\n      return attribute === f && valueAsString === v;\n    });\n  },\n  /**\r\n   * Toggles the refinement value for an attribute.\r\n   * @param {RefinementList} refinementList the initial list\r\n   * @param {string} attribute the attribute to refine\r\n   * @param {string} value the value of the refinement\r\n   * @return {RefinementList} a new and updated list\r\n   */\n  toggleRefinement: function toggleRefinement(refinementList, attribute, value) {\n    if (value === undefined) throw new Error('toggleRefinement should be used with a value');\n    if (lib.isRefined(refinementList, attribute, value)) {\n      return lib.removeRefinement(refinementList, attribute, value);\n    }\n    return lib.addRefinement(refinementList, attribute, value);\n  },\n  /**\r\n   * Clear all or parts of a RefinementList. Depending on the arguments, three\r\n   * kinds of behavior can happen:\r\n   *  - if no attribute is provided: clears the whole list\r\n   *  - if an attribute is provided as a string: clears the list for the specific attribute\r\n   *  - if an attribute is provided as a function: discards the elements for which the function returns true\r\n   * @param {RefinementList} refinementList the initial list\r\n   * @param {string} [attribute] the attribute or function to discard\r\n   * @param {string} [refinementType] optional parameter to give more context to the attribute function\r\n   * @return {RefinementList} a new and updated refinement list\r\n   */\n  clearRefinement: function clearRefinement(refinementList, attribute, refinementType) {\n    if (attribute === undefined) {\n      // return the same object if the list is already empty\n      // this is mainly for tests, as it doesn't have much impact on performance\n      if (!objectHasKeys(refinementList)) {\n        return refinementList;\n      }\n      return {};\n    } else if (typeof attribute === 'string') {\n      return omit(refinementList, [attribute]);\n    } else if (typeof attribute === 'function') {\n      var hasChanged = false;\n      var newRefinementList = Object.keys(refinementList).reduce(function (memo, key) {\n        var values = refinementList[key] || [];\n        var facetList = values.filter(function (value) {\n          return !attribute(value, key, refinementType);\n        });\n        if (facetList.length !== values.length) {\n          hasChanged = true;\n        }\n        memo[key] = facetList;\n        return memo;\n      }, {});\n      if (hasChanged) return newRefinementList;\n      return refinementList;\n    }\n\n    // We return nothing if the attribute is not undefined, a string or a function,\n    // as it is not a valid value for a refinement\n    return undefined;\n  },\n  /**\r\n   * Test if the refinement value is used for the attribute. If no refinement value\r\n   * is provided, test if the refinementList contains any refinement for the\r\n   * given attribute.\r\n   * @param {RefinementList} refinementList the list of refinement\r\n   * @param {string} attribute name of the attribute\r\n   * @param {string} [refinementValue] value of the filter/refinement\r\n   * @return {boolean} true if the attribute is refined, false otherwise\r\n   */\n  isRefined: function isRefined(refinementList, attribute, refinementValue) {\n    var containsRefinements = Boolean(refinementList[attribute]) && refinementList[attribute].length > 0;\n    if (refinementValue === undefined || !containsRefinements) {\n      return containsRefinements;\n    }\n    var refinementValueAsString = '' + refinementValue;\n    return refinementList[attribute].indexOf(refinementValueAsString) !== -1;\n  }\n};\nmodule.exports = lib;","map":{"version":3,"names":["defaultsPure","require","objectHasKeys","omit","lib","addRefinement","refinementList","attribute","value","isRefined","valueAsString","facetRefinement","concat","mod","removeRefinement","undefined","clearRefinement","v","f","toggleRefinement","Error","refinementType","hasChanged","newRefinementList","Object","keys","reduce","memo","key","values","facetList","filter","length","refinementValue","containsRefinements","Boolean","refinementValueAsString","indexOf","module","exports"],"sources":["C:/Users/tudor/propr/RepositoryNetlify/node_modules/react-instantsearch-core/node_modules/algoliasearch-helper/src/SearchParameters/RefinementList.js"],"sourcesContent":["'use strict';\r\n\r\n/**\r\n * Functions to manipulate refinement lists\r\n *\r\n * The RefinementList is not formally defined through a prototype but is based\r\n * on a specific structure.\r\n *\r\n * @module SearchParameters.refinementList\r\n *\r\n * @typedef {string[]} SearchParameters.refinementList.Refinements\r\n * @typedef {Object.<string, SearchParameters.refinementList.Refinements>} SearchParameters.refinementList.RefinementList\r\n */\r\n\r\nvar defaultsPure = require('../functions/defaultsPure');\r\nvar objectHasKeys = require('../functions/objectHasKeys');\r\nvar omit = require('../functions/omit');\r\n\r\nvar lib = {\r\n  /**\r\n   * Adds a refinement to a RefinementList\r\n   * @param {RefinementList} refinementList the initial list\r\n   * @param {string} attribute the attribute to refine\r\n   * @param {string} value the value of the refinement, if the value is not a string it will be converted\r\n   * @return {RefinementList} a new and updated refinement list\r\n   */\r\n  addRefinement: function addRefinement(refinementList, attribute, value) {\r\n    if (lib.isRefined(refinementList, attribute, value)) {\r\n      return refinementList;\r\n    }\r\n\r\n    var valueAsString = '' + value;\r\n\r\n    var facetRefinement = !refinementList[attribute]\r\n      ? [valueAsString]\r\n      : refinementList[attribute].concat(valueAsString);\r\n\r\n    var mod = {};\r\n\r\n    mod[attribute] = facetRefinement;\r\n\r\n    return defaultsPure({}, mod, refinementList);\r\n  },\r\n  /**\r\n   * Removes refinement(s) for an attribute:\r\n   *  - if the value is specified removes the refinement for the value on the attribute\r\n   *  - if no value is specified removes all the refinements for this attribute\r\n   * @param {RefinementList} refinementList the initial list\r\n   * @param {string} attribute the attribute to refine\r\n   * @param {string} [value] the value of the refinement\r\n   * @return {RefinementList} a new and updated refinement lst\r\n   */\r\n  removeRefinement: function removeRefinement(\r\n    refinementList,\r\n    attribute,\r\n    value\r\n  ) {\r\n    if (value === undefined) {\r\n      // we use the \"filter\" form of clearRefinement, since it leaves empty values as-is\r\n      // the form with a string will remove the attribute completely\r\n      return lib.clearRefinement(refinementList, function (v, f) {\r\n        return attribute === f;\r\n      });\r\n    }\r\n\r\n    var valueAsString = '' + value;\r\n\r\n    return lib.clearRefinement(refinementList, function (v, f) {\r\n      return attribute === f && valueAsString === v;\r\n    });\r\n  },\r\n  /**\r\n   * Toggles the refinement value for an attribute.\r\n   * @param {RefinementList} refinementList the initial list\r\n   * @param {string} attribute the attribute to refine\r\n   * @param {string} value the value of the refinement\r\n   * @return {RefinementList} a new and updated list\r\n   */\r\n  toggleRefinement: function toggleRefinement(\r\n    refinementList,\r\n    attribute,\r\n    value\r\n  ) {\r\n    if (value === undefined)\r\n      throw new Error('toggleRefinement should be used with a value');\r\n\r\n    if (lib.isRefined(refinementList, attribute, value)) {\r\n      return lib.removeRefinement(refinementList, attribute, value);\r\n    }\r\n\r\n    return lib.addRefinement(refinementList, attribute, value);\r\n  },\r\n  /**\r\n   * Clear all or parts of a RefinementList. Depending on the arguments, three\r\n   * kinds of behavior can happen:\r\n   *  - if no attribute is provided: clears the whole list\r\n   *  - if an attribute is provided as a string: clears the list for the specific attribute\r\n   *  - if an attribute is provided as a function: discards the elements for which the function returns true\r\n   * @param {RefinementList} refinementList the initial list\r\n   * @param {string} [attribute] the attribute or function to discard\r\n   * @param {string} [refinementType] optional parameter to give more context to the attribute function\r\n   * @return {RefinementList} a new and updated refinement list\r\n   */\r\n  clearRefinement: function clearRefinement(\r\n    refinementList,\r\n    attribute,\r\n    refinementType\r\n  ) {\r\n    if (attribute === undefined) {\r\n      // return the same object if the list is already empty\r\n      // this is mainly for tests, as it doesn't have much impact on performance\r\n      if (!objectHasKeys(refinementList)) {\r\n        return refinementList;\r\n      }\r\n      return {};\r\n    } else if (typeof attribute === 'string') {\r\n      return omit(refinementList, [attribute]);\r\n    } else if (typeof attribute === 'function') {\r\n      var hasChanged = false;\r\n\r\n      var newRefinementList = Object.keys(refinementList).reduce(function (\r\n        memo,\r\n        key\r\n      ) {\r\n        var values = refinementList[key] || [];\r\n        var facetList = values.filter(function (value) {\r\n          return !attribute(value, key, refinementType);\r\n        });\r\n\r\n        if (facetList.length !== values.length) {\r\n          hasChanged = true;\r\n        }\r\n\r\n        memo[key] = facetList;\r\n\r\n        return memo;\r\n      },\r\n      {});\r\n\r\n      if (hasChanged) return newRefinementList;\r\n      return refinementList;\r\n    }\r\n\r\n    // We return nothing if the attribute is not undefined, a string or a function,\r\n    // as it is not a valid value for a refinement\r\n    return undefined;\r\n  },\r\n  /**\r\n   * Test if the refinement value is used for the attribute. If no refinement value\r\n   * is provided, test if the refinementList contains any refinement for the\r\n   * given attribute.\r\n   * @param {RefinementList} refinementList the list of refinement\r\n   * @param {string} attribute name of the attribute\r\n   * @param {string} [refinementValue] value of the filter/refinement\r\n   * @return {boolean} true if the attribute is refined, false otherwise\r\n   */\r\n  isRefined: function isRefined(refinementList, attribute, refinementValue) {\r\n    var containsRefinements =\r\n      Boolean(refinementList[attribute]) &&\r\n      refinementList[attribute].length > 0;\r\n\r\n    if (refinementValue === undefined || !containsRefinements) {\r\n      return containsRefinements;\r\n    }\r\n\r\n    var refinementValueAsString = '' + refinementValue;\r\n\r\n    return refinementList[attribute].indexOf(refinementValueAsString) !== -1;\r\n  },\r\n};\r\n\r\nmodule.exports = lib;\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}