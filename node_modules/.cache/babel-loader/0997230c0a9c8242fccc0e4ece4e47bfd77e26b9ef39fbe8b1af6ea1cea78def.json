{"ast":null,"code":"'use strict';\n\nmodule.exports = generateTrees;\nvar fv = require('../functions/escapeFacetValue');\nvar find = require('../functions/find');\nvar prepareHierarchicalFacetSortBy = require('../functions/formatSort');\nvar orderBy = require('../functions/orderBy');\nvar escapeFacetValue = fv.escapeFacetValue;\nvar unescapeFacetValue = fv.unescapeFacetValue;\nfunction generateTrees(state) {\n  return function generate(hierarchicalFacetResult, hierarchicalFacetIndex) {\n    var hierarchicalFacet = state.hierarchicalFacets[hierarchicalFacetIndex];\n    var hierarchicalFacetRefinement = state.hierarchicalFacetsRefinements[hierarchicalFacet.name] && state.hierarchicalFacetsRefinements[hierarchicalFacet.name][0] || '';\n    var hierarchicalSeparator = state._getHierarchicalFacetSeparator(hierarchicalFacet);\n    var hierarchicalRootPath = state._getHierarchicalRootPath(hierarchicalFacet);\n    var hierarchicalShowParentLevel = state._getHierarchicalShowParentLevel(hierarchicalFacet);\n    var sortBy = prepareHierarchicalFacetSortBy(state._getHierarchicalFacetSortBy(hierarchicalFacet));\n    var rootExhaustive = hierarchicalFacetResult.every(function (facetResult) {\n      return facetResult.exhaustive;\n    });\n    var generateTreeFn = generateHierarchicalTree(sortBy, hierarchicalSeparator, hierarchicalRootPath, hierarchicalShowParentLevel, hierarchicalFacetRefinement);\n    var results = hierarchicalFacetResult;\n    if (hierarchicalRootPath) {\n      results = hierarchicalFacetResult.slice(hierarchicalRootPath.split(hierarchicalSeparator).length);\n    }\n    return results.reduce(generateTreeFn, {\n      name: state.hierarchicalFacets[hierarchicalFacetIndex].name,\n      count: null,\n      // root level, no count\n      isRefined: true,\n      // root level, always refined\n      path: null,\n      // root level, no path\n      escapedValue: null,\n      exhaustive: rootExhaustive,\n      data: null\n    });\n  };\n}\nfunction generateHierarchicalTree(sortBy, hierarchicalSeparator, hierarchicalRootPath, hierarchicalShowParentLevel, currentRefinement) {\n  return function generateTree(hierarchicalTree, hierarchicalFacetResult, currentHierarchicalLevel) {\n    var parent = hierarchicalTree;\n    if (currentHierarchicalLevel > 0) {\n      var level = 0;\n      parent = hierarchicalTree;\n      while (level < currentHierarchicalLevel) {\n        /**\r\n         * @type {object[]]} hierarchical data\r\n         */\n        var data = parent && Array.isArray(parent.data) ? parent.data : [];\n        parent = find(data, function (subtree) {\n          return subtree.isRefined;\n        });\n        level++;\n      }\n    }\n\n    // we found a refined parent, let's add current level data under it\n    if (parent) {\n      // filter values in case an object has multiple categories:\n      //   {\n      //     categories: {\n      //       level0: ['beers', 'bières'],\n      //       level1: ['beers > IPA', 'bières > Belges']\n      //     }\n      //   }\n      //\n      // If parent refinement is `beers`, then we do not want to have `bières > Belges`\n      // showing up\n\n      var picked = Object.keys(hierarchicalFacetResult.data).map(function (facetValue) {\n        return [facetValue, hierarchicalFacetResult.data[facetValue]];\n      }).filter(function (tuple) {\n        var facetValue = tuple[0];\n        return onlyMatchingTree(facetValue, parent.path || hierarchicalRootPath, currentRefinement, hierarchicalSeparator, hierarchicalRootPath, hierarchicalShowParentLevel);\n      });\n      parent.data = orderBy(picked.map(function (tuple) {\n        var facetValue = tuple[0];\n        var facetCount = tuple[1];\n        return format(facetCount, facetValue, hierarchicalSeparator, unescapeFacetValue(currentRefinement), hierarchicalFacetResult.exhaustive);\n      }), sortBy[0], sortBy[1]);\n    }\n    return hierarchicalTree;\n  };\n}\n\n// eslint-disable-next-line max-params\nfunction onlyMatchingTree(facetValue, parentPath, currentRefinement, hierarchicalSeparator, hierarchicalRootPath, hierarchicalShowParentLevel) {\n  // we want the facetValue is a child of hierarchicalRootPath\n  if (hierarchicalRootPath && (facetValue.indexOf(hierarchicalRootPath) !== 0 || hierarchicalRootPath === facetValue)) {\n    return false;\n  }\n\n  // we always want root levels (only when there is no prefix path)\n  return !hierarchicalRootPath && facetValue.indexOf(hierarchicalSeparator) === -1 ||\n  // if there is a rootPath, being root level mean 1 level under rootPath\n  hierarchicalRootPath && facetValue.split(hierarchicalSeparator).length - hierarchicalRootPath.split(hierarchicalSeparator).length === 1 ||\n  // if current refinement is a root level and current facetValue is a root level,\n  // keep the facetValue\n  facetValue.indexOf(hierarchicalSeparator) === -1 && currentRefinement.indexOf(hierarchicalSeparator) === -1 ||\n  // currentRefinement is a child of the facet value\n  currentRefinement.indexOf(facetValue) === 0 ||\n  // facetValue is a child of the current parent, add it\n  facetValue.indexOf(parentPath + hierarchicalSeparator) === 0 && (hierarchicalShowParentLevel || facetValue.indexOf(currentRefinement) === 0);\n}\nfunction format(facetCount, facetValue, hierarchicalSeparator, currentRefinement, exhaustive) {\n  var parts = facetValue.split(hierarchicalSeparator);\n  return {\n    name: parts[parts.length - 1].trim(),\n    path: facetValue,\n    escapedValue: escapeFacetValue(facetValue),\n    count: facetCount,\n    isRefined: currentRefinement === facetValue || currentRefinement.indexOf(facetValue + hierarchicalSeparator) === 0,\n    exhaustive: exhaustive,\n    data: null\n  };\n}","map":{"version":3,"names":["module","exports","generateTrees","fv","require","find","prepareHierarchicalFacetSortBy","orderBy","escapeFacetValue","unescapeFacetValue","state","generate","hierarchicalFacetResult","hierarchicalFacetIndex","hierarchicalFacet","hierarchicalFacets","hierarchicalFacetRefinement","hierarchicalFacetsRefinements","name","hierarchicalSeparator","_getHierarchicalFacetSeparator","hierarchicalRootPath","_getHierarchicalRootPath","hierarchicalShowParentLevel","_getHierarchicalShowParentLevel","sortBy","_getHierarchicalFacetSortBy","rootExhaustive","every","facetResult","exhaustive","generateTreeFn","generateHierarchicalTree","results","slice","split","length","reduce","count","isRefined","path","escapedValue","data","currentRefinement","generateTree","hierarchicalTree","currentHierarchicalLevel","parent","level","Array","isArray","subtree","picked","Object","keys","map","facetValue","filter","tuple","onlyMatchingTree","facetCount","format","parentPath","indexOf","parts","trim"],"sources":["C:/Users/tudor/propr/RepositoryNetlify/node_modules/react-instantsearch-core/node_modules/algoliasearch-helper/src/SearchResults/generate-hierarchical-tree.js"],"sourcesContent":["'use strict';\r\n\r\nmodule.exports = generateTrees;\r\n\r\nvar fv = require('../functions/escapeFacetValue');\r\nvar find = require('../functions/find');\r\nvar prepareHierarchicalFacetSortBy = require('../functions/formatSort');\r\nvar orderBy = require('../functions/orderBy');\r\nvar escapeFacetValue = fv.escapeFacetValue;\r\nvar unescapeFacetValue = fv.unescapeFacetValue;\r\n\r\nfunction generateTrees(state) {\r\n  return function generate(hierarchicalFacetResult, hierarchicalFacetIndex) {\r\n    var hierarchicalFacet = state.hierarchicalFacets[hierarchicalFacetIndex];\r\n    var hierarchicalFacetRefinement =\r\n      (state.hierarchicalFacetsRefinements[hierarchicalFacet.name] &&\r\n        state.hierarchicalFacetsRefinements[hierarchicalFacet.name][0]) ||\r\n      '';\r\n    var hierarchicalSeparator =\r\n      state._getHierarchicalFacetSeparator(hierarchicalFacet);\r\n    var hierarchicalRootPath =\r\n      state._getHierarchicalRootPath(hierarchicalFacet);\r\n    var hierarchicalShowParentLevel =\r\n      state._getHierarchicalShowParentLevel(hierarchicalFacet);\r\n    var sortBy = prepareHierarchicalFacetSortBy(\r\n      state._getHierarchicalFacetSortBy(hierarchicalFacet)\r\n    );\r\n\r\n    var rootExhaustive = hierarchicalFacetResult.every(function (facetResult) {\r\n      return facetResult.exhaustive;\r\n    });\r\n\r\n    var generateTreeFn = generateHierarchicalTree(\r\n      sortBy,\r\n      hierarchicalSeparator,\r\n      hierarchicalRootPath,\r\n      hierarchicalShowParentLevel,\r\n      hierarchicalFacetRefinement\r\n    );\r\n\r\n    var results = hierarchicalFacetResult;\r\n\r\n    if (hierarchicalRootPath) {\r\n      results = hierarchicalFacetResult.slice(\r\n        hierarchicalRootPath.split(hierarchicalSeparator).length\r\n      );\r\n    }\r\n\r\n    return results.reduce(generateTreeFn, {\r\n      name: state.hierarchicalFacets[hierarchicalFacetIndex].name,\r\n      count: null, // root level, no count\r\n      isRefined: true, // root level, always refined\r\n      path: null, // root level, no path\r\n      escapedValue: null,\r\n      exhaustive: rootExhaustive,\r\n      data: null,\r\n    });\r\n  };\r\n}\r\n\r\nfunction generateHierarchicalTree(\r\n  sortBy,\r\n  hierarchicalSeparator,\r\n  hierarchicalRootPath,\r\n  hierarchicalShowParentLevel,\r\n  currentRefinement\r\n) {\r\n  return function generateTree(\r\n    hierarchicalTree,\r\n    hierarchicalFacetResult,\r\n    currentHierarchicalLevel\r\n  ) {\r\n    var parent = hierarchicalTree;\r\n\r\n    if (currentHierarchicalLevel > 0) {\r\n      var level = 0;\r\n\r\n      parent = hierarchicalTree;\r\n\r\n      while (level < currentHierarchicalLevel) {\r\n        /**\r\n         * @type {object[]]} hierarchical data\r\n         */\r\n        var data = parent && Array.isArray(parent.data) ? parent.data : [];\r\n        parent = find(data, function (subtree) {\r\n          return subtree.isRefined;\r\n        });\r\n        level++;\r\n      }\r\n    }\r\n\r\n    // we found a refined parent, let's add current level data under it\r\n    if (parent) {\r\n      // filter values in case an object has multiple categories:\r\n      //   {\r\n      //     categories: {\r\n      //       level0: ['beers', 'bières'],\r\n      //       level1: ['beers > IPA', 'bières > Belges']\r\n      //     }\r\n      //   }\r\n      //\r\n      // If parent refinement is `beers`, then we do not want to have `bières > Belges`\r\n      // showing up\r\n\r\n      var picked = Object.keys(hierarchicalFacetResult.data)\r\n        .map(function (facetValue) {\r\n          return [facetValue, hierarchicalFacetResult.data[facetValue]];\r\n        })\r\n        .filter(function (tuple) {\r\n          var facetValue = tuple[0];\r\n          return onlyMatchingTree(\r\n            facetValue,\r\n            parent.path || hierarchicalRootPath,\r\n            currentRefinement,\r\n            hierarchicalSeparator,\r\n            hierarchicalRootPath,\r\n            hierarchicalShowParentLevel\r\n          );\r\n        });\r\n\r\n      parent.data = orderBy(\r\n        picked.map(function (tuple) {\r\n          var facetValue = tuple[0];\r\n          var facetCount = tuple[1];\r\n\r\n          return format(\r\n            facetCount,\r\n            facetValue,\r\n            hierarchicalSeparator,\r\n            unescapeFacetValue(currentRefinement),\r\n            hierarchicalFacetResult.exhaustive\r\n          );\r\n        }),\r\n        sortBy[0],\r\n        sortBy[1]\r\n      );\r\n    }\r\n\r\n    return hierarchicalTree;\r\n  };\r\n}\r\n\r\n// eslint-disable-next-line max-params\r\nfunction onlyMatchingTree(\r\n  facetValue,\r\n  parentPath,\r\n  currentRefinement,\r\n  hierarchicalSeparator,\r\n  hierarchicalRootPath,\r\n  hierarchicalShowParentLevel\r\n) {\r\n  // we want the facetValue is a child of hierarchicalRootPath\r\n  if (\r\n    hierarchicalRootPath &&\r\n    (facetValue.indexOf(hierarchicalRootPath) !== 0 ||\r\n      hierarchicalRootPath === facetValue)\r\n  ) {\r\n    return false;\r\n  }\r\n\r\n  // we always want root levels (only when there is no prefix path)\r\n  return (\r\n    (!hierarchicalRootPath &&\r\n      facetValue.indexOf(hierarchicalSeparator) === -1) ||\r\n    // if there is a rootPath, being root level mean 1 level under rootPath\r\n    (hierarchicalRootPath &&\r\n      facetValue.split(hierarchicalSeparator).length -\r\n        hierarchicalRootPath.split(hierarchicalSeparator).length ===\r\n        1) ||\r\n    // if current refinement is a root level and current facetValue is a root level,\r\n    // keep the facetValue\r\n    (facetValue.indexOf(hierarchicalSeparator) === -1 &&\r\n      currentRefinement.indexOf(hierarchicalSeparator) === -1) ||\r\n    // currentRefinement is a child of the facet value\r\n    currentRefinement.indexOf(facetValue) === 0 ||\r\n    // facetValue is a child of the current parent, add it\r\n    (facetValue.indexOf(parentPath + hierarchicalSeparator) === 0 &&\r\n      (hierarchicalShowParentLevel ||\r\n        facetValue.indexOf(currentRefinement) === 0))\r\n  );\r\n}\r\n\r\nfunction format(\r\n  facetCount,\r\n  facetValue,\r\n  hierarchicalSeparator,\r\n  currentRefinement,\r\n  exhaustive\r\n) {\r\n  var parts = facetValue.split(hierarchicalSeparator);\r\n  return {\r\n    name: parts[parts.length - 1].trim(),\r\n    path: facetValue,\r\n    escapedValue: escapeFacetValue(facetValue),\r\n    count: facetCount,\r\n    isRefined:\r\n      currentRefinement === facetValue ||\r\n      currentRefinement.indexOf(facetValue + hierarchicalSeparator) === 0,\r\n    exhaustive: exhaustive,\r\n    data: null,\r\n  };\r\n}\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}