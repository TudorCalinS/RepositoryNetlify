{"ast":null,"code":"import PropTypes from 'prop-types';\nimport createConnector from \"../core/createConnector.js\";\nimport { getCurrentRefinementValue, hasMultipleIndices, getIndexId } from \"../core/indexUtils.js\";\nimport { shallowEqual, omit } from \"../core/utils.js\";\n\n/**\r\n * connectScrollTo connector provides the logic to build a widget that will\r\n * let the page scroll to a certain point.\r\n * @name connectScrollTo\r\n * @kind connector\r\n * @propType {string} [scrollOn=\"page\"] - Widget searchState key on which to listen for changes, default to the pagination widget.\r\n * @providedPropType {any} value - the current refinement applied to the widget listened by scrollTo\r\n * @providedPropType {boolean} hasNotChanged - indicates whether the refinement came from the scrollOn argument (for instance page by default)\r\n */\nexport default createConnector({\n  displayName: 'AlgoliaScrollTo',\n  $$type: 'ais.scrollTo',\n  propTypes: {\n    scrollOn: PropTypes.string\n  },\n  defaultProps: {\n    scrollOn: 'page'\n  },\n  getProvidedProps: function getProvidedProps(props, searchState) {\n    var id = props.scrollOn;\n    var value = getCurrentRefinementValue(props, searchState, {\n      ais: props.contextValue,\n      multiIndexContext: props.indexContextValue\n    }, id, null);\n    if (!this._prevSearchState) {\n      this._prevSearchState = {};\n    }\n\n    // Get the subpart of the state that interest us\n    if (hasMultipleIndices({\n      ais: props.contextValue,\n      multiIndexContext: props.indexContextValue\n    })) {\n      searchState = searchState.indices ? searchState.indices[getIndexId({\n        ais: props.contextValue,\n        multiIndexContext: props.indexContextValue\n      })] : {};\n    }\n\n    // if there is a change in the app that has been triggered by another element\n    // than \"props.scrollOn (id) or the Configure widget, we need to keep track of\n    // the search state to know if there's a change in the app that was not triggered\n    // by the props.scrollOn (id) or the Configure widget. This is useful when\n    // using ScrollTo in combination of Pagination. As pagination can be change\n    // by every widget, we want to scroll only if it cames from the pagination\n    // widget itself. We also remove the configure key from the search state to\n    // do this comparison because for now configure values are not present in the\n    // search state before a first refinement has been made and will false the results.\n    // See: https://github.com/algolia/react-instantsearch/issues/164\n    var cleanedSearchState = omit(searchState, ['configure', id]);\n    var hasNotChanged = shallowEqual(this._prevSearchState, cleanedSearchState);\n    this._prevSearchState = cleanedSearchState;\n    return {\n      value: value,\n      hasNotChanged: hasNotChanged\n    };\n  }\n});","map":{"version":3,"names":["PropTypes","createConnector","getCurrentRefinementValue","hasMultipleIndices","getIndexId","shallowEqual","omit","displayName","$$type","propTypes","scrollOn","string","defaultProps","getProvidedProps","props","searchState","id","value","ais","contextValue","multiIndexContext","indexContextValue","_prevSearchState","indices","cleanedSearchState","hasNotChanged"],"sources":["C:/Users/tudor/propr/RepositoryNetlify/node_modules/react-instantsearch-core/dist/es/connectors/connectScrollTo.js"],"sourcesContent":["import PropTypes from 'prop-types';\r\nimport createConnector from \"../core/createConnector.js\";\r\nimport { getCurrentRefinementValue, hasMultipleIndices, getIndexId } from \"../core/indexUtils.js\";\r\nimport { shallowEqual, omit } from \"../core/utils.js\";\r\n\r\n/**\r\n * connectScrollTo connector provides the logic to build a widget that will\r\n * let the page scroll to a certain point.\r\n * @name connectScrollTo\r\n * @kind connector\r\n * @propType {string} [scrollOn=\"page\"] - Widget searchState key on which to listen for changes, default to the pagination widget.\r\n * @providedPropType {any} value - the current refinement applied to the widget listened by scrollTo\r\n * @providedPropType {boolean} hasNotChanged - indicates whether the refinement came from the scrollOn argument (for instance page by default)\r\n */\r\nexport default createConnector({\r\n  displayName: 'AlgoliaScrollTo',\r\n  $$type: 'ais.scrollTo',\r\n  propTypes: {\r\n    scrollOn: PropTypes.string\r\n  },\r\n  defaultProps: {\r\n    scrollOn: 'page'\r\n  },\r\n  getProvidedProps: function getProvidedProps(props, searchState) {\r\n    var id = props.scrollOn;\r\n    var value = getCurrentRefinementValue(props, searchState, {\r\n      ais: props.contextValue,\r\n      multiIndexContext: props.indexContextValue\r\n    }, id, null);\r\n    if (!this._prevSearchState) {\r\n      this._prevSearchState = {};\r\n    }\r\n\r\n    // Get the subpart of the state that interest us\r\n    if (hasMultipleIndices({\r\n      ais: props.contextValue,\r\n      multiIndexContext: props.indexContextValue\r\n    })) {\r\n      searchState = searchState.indices ? searchState.indices[getIndexId({\r\n        ais: props.contextValue,\r\n        multiIndexContext: props.indexContextValue\r\n      })] : {};\r\n    }\r\n\r\n    // if there is a change in the app that has been triggered by another element\r\n    // than \"props.scrollOn (id) or the Configure widget, we need to keep track of\r\n    // the search state to know if there's a change in the app that was not triggered\r\n    // by the props.scrollOn (id) or the Configure widget. This is useful when\r\n    // using ScrollTo in combination of Pagination. As pagination can be change\r\n    // by every widget, we want to scroll only if it cames from the pagination\r\n    // widget itself. We also remove the configure key from the search state to\r\n    // do this comparison because for now configure values are not present in the\r\n    // search state before a first refinement has been made and will false the results.\r\n    // See: https://github.com/algolia/react-instantsearch/issues/164\r\n    var cleanedSearchState = omit(searchState, ['configure', id]);\r\n    var hasNotChanged = shallowEqual(this._prevSearchState, cleanedSearchState);\r\n    this._prevSearchState = cleanedSearchState;\r\n    return {\r\n      value: value,\r\n      hasNotChanged: hasNotChanged\r\n    };\r\n  }\r\n});"],"mappings":"AAAA,OAAOA,SAAS,MAAM,YAAY;AAClC,OAAOC,eAAe,MAAM,4BAA4B;AACxD,SAASC,yBAAyB,EAAEC,kBAAkB,EAAEC,UAAU,QAAQ,uBAAuB;AACjG,SAASC,YAAY,EAAEC,IAAI,QAAQ,kBAAkB;;AAErD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAeL,eAAe,CAAC;EAC7BM,WAAW,EAAE,iBAAiB;EAC9BC,MAAM,EAAE,cAAc;EACtBC,SAAS,EAAE;IACTC,QAAQ,EAAEV,SAAS,CAACW;EACtB,CAAC;EACDC,YAAY,EAAE;IACZF,QAAQ,EAAE;EACZ,CAAC;EACDG,gBAAgB,EAAE,SAASA,gBAAgBA,CAACC,KAAK,EAAEC,WAAW,EAAE;IAC9D,IAAIC,EAAE,GAAGF,KAAK,CAACJ,QAAQ;IACvB,IAAIO,KAAK,GAAGf,yBAAyB,CAACY,KAAK,EAAEC,WAAW,EAAE;MACxDG,GAAG,EAAEJ,KAAK,CAACK,YAAY;MACvBC,iBAAiB,EAAEN,KAAK,CAACO;IAC3B,CAAC,EAAEL,EAAE,EAAE,IAAI,CAAC;IACZ,IAAI,CAAC,IAAI,CAACM,gBAAgB,EAAE;MAC1B,IAAI,CAACA,gBAAgB,GAAG,CAAC,CAAC;IAC5B;;IAEA;IACA,IAAInB,kBAAkB,CAAC;MACrBe,GAAG,EAAEJ,KAAK,CAACK,YAAY;MACvBC,iBAAiB,EAAEN,KAAK,CAACO;IAC3B,CAAC,CAAC,EAAE;MACFN,WAAW,GAAGA,WAAW,CAACQ,OAAO,GAAGR,WAAW,CAACQ,OAAO,CAACnB,UAAU,CAAC;QACjEc,GAAG,EAAEJ,KAAK,CAACK,YAAY;QACvBC,iBAAiB,EAAEN,KAAK,CAACO;MAC3B,CAAC,CAAC,CAAC,GAAG,CAAC,CAAC;IACV;;IAEA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA,IAAIG,kBAAkB,GAAGlB,IAAI,CAACS,WAAW,EAAE,CAAC,WAAW,EAAEC,EAAE,CAAC,CAAC;IAC7D,IAAIS,aAAa,GAAGpB,YAAY,CAAC,IAAI,CAACiB,gBAAgB,EAAEE,kBAAkB,CAAC;IAC3E,IAAI,CAACF,gBAAgB,GAAGE,kBAAkB;IAC1C,OAAO;MACLP,KAAK,EAAEA,KAAK;MACZQ,aAAa,EAAEA;IACjB,CAAC;EACH;AACF,CAAC,CAAC","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}